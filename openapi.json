{
  "openapi": "3.1.0",
  "info": {
    "contact": {
      "email": "support@flussonic.com",
      "name": "Support team",
      "url": "https://flussonic.com/"
    },
    "description": "This is a client API for Watcher VMS. \n\nThis API is designed for accessing content including cameras, mosaics, episodes, reports, etc.\nThe access is subject to user permissions so you will need login and password in order to execute the requests.\nUse [Watcher Admin API](https://flussonic.com/doc/api/watcher-admin/) for managing users, permissions, and other infrastructure.\n\nYou can use this API to develop your own UI for your subscribers who use Watcher\nor for integration with an external system that needs the access to the content. \n",
    "title": "Watcher Client API",
    "version": "24.11-844"
  },
  "components": {
    "schemas": {
      "collection_response": {
        "type": "object",
        "properties": {
          "estimated_count": {
            "description": "Estimated total number of records for the query (regardless of the cursors).\n",
            "type": "integer",
            "example": 5
          },
          "next": {
            "description": "Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.\nLearn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).\n",
            "example": "JTI0cG9zaXRpb25fZ3Q9MA==",
            "type": "string"
          },
          "prev": {
            "description": "Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.\nLearn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).\n",
            "example": "JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl",
            "type": "string"
          },
          "timing": {
            "description": "An object with a list of different timings measured during this API call.",
            "type": "object"
          }
        }
      },
      "error_response": {
        "type": "object",
        "properties": {
          "errors": {
            "description": "List of structured errors",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/error"
            }
          }
        }
      },
      "ui_settings_config": {
        "type": "object",
        "properties": {
          "title": {
            "description": "The product title.",
            "type": "string",
            "examples": {
              "flussonic": {
                "value": "Streamer",
                "x-scope": [
                  "flussonic"
                ]
              },
              "central": {
                "value": "Central",
                "x-scope": [
                  "central"
                ]
              },
              "cloud": {
                "value": "Cloud",
                "x-scope": [
                  "cloud"
                ]
              },
              "client-area": {
                "value": "Billing",
                "x-scope": [
                  "client-area"
                ]
              }
            }
          },
          "brand": {
            "description": "The product brand.",
            "type": "string",
            "examples": {
              "flussonic": {
                "value": "Streamer",
                "x-scope": [
                  "flussonic"
                ]
              },
              "central": {
                "value": "Central",
                "x-scope": [
                  "central"
                ]
              },
              "cloud": {
                "value": "Cloud",
                "x-scope": [
                  "cloud"
                ]
              }
            }
          },
          "product": {
            "description": "The product type.",
            "type": "string",
            "examples": {
              "flussonic": {
                "value": "streamer",
                "x-scope": [
                  "flussonic"
                ]
              },
              "central": {
                "value": "central",
                "x-scope": [
                  "central"
                ]
              },
              "cloud": {
                "value": "cloud",
                "x-scope": [
                  "cloud"
                ]
              }
            }
          },
          "fonts": {
            "description": "The fonts in the UI.",
            "type": "object",
            "properties": {
              "light": {
                "description": "The light font style.",
                "type": "string",
                "x-private": true,
                "example": "fira-sans-300.woff2",
                "format": "byte",
                "x-notice": "file_base64",
                "x-format-description": "byte"
              },
              "regular": {
                "description": "The regular font style.",
                "type": "string",
                "x-private": true,
                "example": "fira-sans-400.woff2",
                "format": "byte",
                "x-notice": "file_base64",
                "x-format-description": "byte"
              },
              "medium": {
                "description": "The medium font style.",
                "type": "string",
                "x-private": true,
                "example": "fira-sans-500.woff2",
                "format": "byte",
                "x-notice": "file_base64",
                "x-format-description": "byte"
              }
            }
          },
          "favicons": {
            "description": "The favicons of different sizes for different OSes and browsers.",
            "type": "object",
            "properties": {
              "16": {
                "description": "16x16 pixels favicon.",
                "type": "string",
                "x-private": true,
                "format": "byte",
                "example": "icons/favicon-16.png",
                "x-format-description": "byte"
              },
              "32": {
                "description": "32x32 pixels favicon.",
                "type": "string",
                "x-private": true,
                "example": "icons/favicon-32.png",
                "format": "byte",
                "x-notice": "file_base64",
                "x-format-description": "byte"
              },
              "48": {
                "description": "48x48 pixels favicon.",
                "type": "string",
                "x-private": true,
                "example": "icons/favicon-48.png",
                "format": "byte",
                "x-notice": "file_base64",
                "x-format-description": "byte"
              },
              "64": {
                "description": "64x64 pixels favicon.",
                "type": "string",
                "x-private": true,
                "example": "icons/favicon-64.png",
                "format": "byte",
                "x-notice": "file_base64",
                "x-format-description": "byte"
              },
              "128": {
                "description": "128x128 pixels favicon.",
                "type": "string",
                "x-private": true,
                "example": "icons/favicon-128.png",
                "format": "byte",
                "x-notice": "file_base64",
                "x-format-description": "byte"
              }
            }
          },
          "colors": {
            "description": "The interface colors.",
            "type": "object",
            "properties": {
              "primary": {
                "description": "Primary color for interface elements like selection in the main menu, info icons, buttons, etc.",
                "type": "string",
                "examples": {
                  "flussonic": {
                    "value": "#002DAB",
                    "x-scope": [
                      "flussonic"
                    ]
                  },
                  "central": {
                    "value": "#4549F2",
                    "x-scope": [
                      "central"
                    ]
                  },
                  "cloud": {
                    "value": "#4549F2",
                    "x-scope": [
                      "cloud"
                    ]
                  },
                  "client-area": {
                    "value": "#002DAB",
                    "x-scope": [
                      "client-area"
                    ]
                  }
                }
              },
              "secondary": {
                "description": "Secondary color for obsolete interface elements like active tab.",
                "type": "string",
                "examples": {
                  "flussonic": {
                    "value": "#FF0D70",
                    "x-scope": [
                      "flussonic"
                    ]
                  },
                  "central": {
                    "value": "#E91E63",
                    "x-scope": [
                      "central"
                    ]
                  },
                  "cloud": {
                    "value": "#E91E63",
                    "x-scope": [
                      "cloud"
                    ]
                  },
                  "client-area": {
                    "value": "#FF0D70",
                    "x-scope": [
                      "client-area"
                    ]
                  }
                }
              },
              "background": {
                "description": "The background color.",
                "type": "string",
                "example": "#fff"
              }
            }
          },
          "locales": {
            "type": "array",
            "description": "The list of possible locales",
            "example": [
              "en",
              "ru"
            ],
            "items": {
              "$ref": "#/components/schemas/locale"
            }
          },
          "default_locale": {
            "description": "The default locale",
            "allOf": [
              {
                "$ref": "#/components/schemas/locale"
              }
            ]
          },
          "company_info": {
            "type": "object",
            "description": "Contact information for customers to reach the company through various means.",
            "properties": {
              "address": {
                "description": "Details enabling customers to locate the company's physical location.",
                "type": "string"
              },
              "phone": {
                "description": "Telephone contact information for reaching out to the company.",
                "type": "string"
              },
              "business_hours": {
                "description": "Notify your users if you are not ready to answer phone calls and emails 24/7.",
                "type": "string"
              }
            }
          },
          "map": {
            "description": "Map settings for displaying streams with specified coordinates.",
            "allOf": [
              {
                "$ref": "#/components/schemas/map"
              }
            ]
          }
        }
      },
      "stream_stats": {
        "type": "object",
        "properties": {
          "lifetime": {
            "type": "number",
            "format": "milliseconds",
            "description": "The time period in seconds during which the stream is being captured.\nCan be calculated from `opened_at`\n",
            "x-api-allow": [
              "central",
              "watcher-core",
              "watcher-client",
              "watcher-admin"
            ],
            "example": 71977,
            "x-format-description": "milliseconds"
          },
          "last_dts_at": {
            "type": "number",
            "format": "utc_ms",
            "description": "The time when the last time frame was sent to the stream output (in UTC).",
            "example": 1636383841974,
            "x-api-allow": [
              "watcher-client",
              "watcher-core",
              "watcher-admin",
              "central"
            ],
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "media_info": {
            "allOf": [
              {
                "$ref": "#/components/schemas/media_info"
              }
            ],
            "description": "Technical information about the output media content.",
            "x-api-allow": [
              "watcher-client",
              "watcher-core",
              "watcher-admin",
              "central",
              "smartcam"
            ]
          },
          "ts_delay": {
            "type": "number",
            "format": "ticks",
            "example": 1284,
            "description": "The time period during which no frames were received from the stream's input.",
            "x-api-allow": [
              "central",
              "watcher-core",
              "watcher-client",
              "watcher-admin"
            ],
            "x-format-description": "ticks"
          },
          "status": {
            "description": "Indicates the status of the stream.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_status"
              }
            ],
            "x-api-allow": [
              "watcher-client",
              "watcher-core",
              "watcher-admin",
              "central",
              "vision"
            ]
          },
          "current_agent_id": {
            "type": "string",
            "format": "agent_id",
            "description": "The identifier of the Agent that is currently serving the stream.",
            "x-api-allow": [
              "watcher-core",
              "central",
              "watcher-client",
              "watcher-admin"
            ],
            "x-format-description": "agent_id"
          },
          "agent_status": {
            "enum": [
              "connected",
              "not_connected",
              "rproxy_not_configured"
            ],
            "type": "string",
            "description": "The status of the Agent serving the stream.",
            "x-api-allow": [
              "watcher-core",
              "central",
              "watcher-client",
              "watcher-admin"
            ]
          },
          "dvr_info": {
            "description": "The information about the recorded DVR archive.",
            "allOf": [
              {
                "$ref": "#/components/schemas/dvr_info"
              }
            ],
            "x-api-allow": [
              "watcher-client",
              "watcher-core",
              "watcher-admin",
              "central",
              "central-layouter"
            ]
          },
          "alive": {
            "default": false,
            "type": "boolean",
            "example": true,
            "description": "Becomes `false` when `ts_delay` > 12000 (= 12 seconds)",
            "x-api-allow": [
              "watcher-client",
              "watcher-core",
              "watcher-admin",
              "central"
            ]
          },
          "bitrate": {
            "type": "integer",
            "format": "speed",
            "description": "Stream bitrate.",
            "openmetrics_metric": "stream_bitrate",
            "x-metric-type": "gauge",
            "example": 186,
            "x-api-allow": [
              "watcher-core",
              "central",
              "watcher-client",
              "watcher-admin"
            ],
            "x-format-description": "speed"
          },
          "playback_token": {
            "description": "Temporary token for playback requests (Media Server Streaming API, Central Streaming API).",
            "type": "string",
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ],
            "example": "onetime_token"
          },
          "streaming_endpoint": {
            "description": "HTTP(s) URL that can be used for streaming API of this stream",
            "type": "string",
            "x-api-allow": [
              "watcher-core",
              "central",
              "watcher-client",
              "watcher-admin"
            ]
          },
          "publish_endpoint": {
            "description": "Publish endpoint. Used to publish the stream.\n",
            "type": "string",
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ],
            "readOnly": true
          },
          "online_clients": {
            "type": "integer",
            "format": "client_count",
            "description": "The number of clients receiving the stream.\nUse play.play_opened_sessions instead\n",
            "openmetrics_metric": "stream_online_clients",
            "x-metric-type": "gauge",
            "example": 3,
            "x-api-allow": [
              "watcher-core",
              "central",
              "watcher-client",
              "watcher-admin"
            ],
            "deprecated": true,
            "x-delete-at": 25.04,
            "x-format-description": "client_count"
          },
          "bytes_out": {
            "type": "integer",
            "format": "bytes",
            "description": "The amount of stream data sent to the clients.",
            "openmetrics_metric": "stream_bytes_out",
            "x-metric-type": "counter",
            "example": 0,
            "x-api-allow": [
              "watcher-core",
              "central",
              "watcher-client",
              "watcher-admin"
            ],
            "x-format-description": "bytes"
          }
        }
      },
      "stream_config_base": {
        "type": "object",
        "properties": {
          "static": {
            "default": true,
            "description": "Whether a stream is `static` or not. \nIf set to `True` the server will try to keep this stream running even if\nthere are no viewers or errors encountered.\n\nStreamer restarts *all* `static` streams even if any internal errors occur\nand the `static` streams crash.\n",
            "type": "boolean",
            "example": true,
            "x-api-allow": [
              "watcher-core",
              "watcher-client",
              "watcher-admin"
            ]
          },
          "disabled": {
            "description": "Whether a stream is disabled. Disabled streams are inactive and do not run. \nDisplayed only with the API calls.\n",
            "type": "boolean",
            "example": false,
            "x-api-allow": [
              "watcher-core",
              "watcher-client",
              "watcher-admin",
              "central-layouter"
            ]
          }
        }
      },
      "stream_config_specific": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "format": "media_name",
            "description": "Globally unique stream name.\nNote that the name could not be changed after the stream is created.\n",
            "x-primary-key": true,
            "openmetrics_label": "name",
            "examples": {
              "default": {
                "value": "hockey1"
              },
              "mylive/bunny": {
                "value": "mylive/bunny"
              },
              "decklink": {
                "value": "Decklink-Stream"
              },
              "dektec": {
                "value": "Dektec-Stream"
              },
              "test_stream": {
                "value": "test_stream"
              }
            },
            "x-api-allow": [
              "watcher-client",
              "watcher-core",
              "watcher-admin",
              "vision-config-external",
              "smartcam",
              "central-layouter",
              "vision"
            ],
            "x-format-description": "media_name"
          },
          "comment": {
            "description": "Human-readable description of the stream.\n",
            "type": "string",
            "example": "This is a test stream",
            "x-api-allow": [
              "watcher-client",
              "watcher-core",
              "watcher-admin"
            ]
          },
          "title": {
            "description": "Human-readable title of the stream. Provided for SDT MPEG-TS table or\nSDP RTSP title parameter.\n",
            "type": "string",
            "example": "Hockey channel",
            "x-api-allow": [
              "watcher-client",
              "watcher-core",
              "watcher-admin"
            ]
          }
        },
        "required": [
          "name"
        ]
      },
      "stream_config_additional": {
        "type": "object",
        "properties": {
          "stats": {
            "description": "Stream's metrics and other statistical information.",
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_stats"
              }
            ],
            "readOnly": true,
            "x-api-allow": [
              "watcher-client",
              "watcher-core",
              "watcher-admin",
              "smartcam",
              "vision",
              "central-layouter"
            ]
          }
        }
      },
      "stream_config_media": {
        "type": "object",
        "properties": {
          "dvr": {
            "description": "DVR configuraton.",
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_dvr_spec"
              }
            ],
            "x-api-allow": [
              "watcher-core",
              "watcher-admin",
              "watcher-client",
              "central-layouter"
            ]
          }
        }
      },
      "stream_config_onpremises": {
        "type": "object",
        "properties": {
          "vision": {
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_spec"
              }
            ],
            "description": "Video analytics parameters.",
            "x-api-allow": [
              "vision-config-external",
              "smartcam",
              "vision",
              "watcher-core",
              "watcher-admin",
              "watcher-client",
              "central-layouter"
            ]
          }
        }
      },
      "stream_dvr_spec": {
        "allOf": [
          {
            "$ref": "#/components/schemas/stream_dvr_specific_spec"
          },
          {
            "$ref": "#/components/schemas/dvr_base_config"
          }
        ]
      },
      "stream_config": {
        "allOf": [
          {
            "$ref": "#/components/schemas/stream_config_specific"
          },
          {
            "$ref": "#/components/schemas/stream_config_base"
          },
          {
            "$ref": "#/components/schemas/stream_config_additional"
          },
          {
            "$ref": "#/components/schemas/stream_config_input"
          },
          {
            "$ref": "#/components/schemas/stream_config_media"
          },
          {
            "$ref": "#/components/schemas/stream_config_onpremises"
          },
          {
            "$ref": "#/components/schemas/watcher_stream_config"
          },
          {
            "$ref": "#/components/schemas/camera_tag_wb"
          }
        ]
      },
      "stream_config_multiedit": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Stream name",
            "x-primary-key": true,
            "x-api-allow": [
              "watcher-admin",
              "watcher-client"
            ]
          },
          "preset_id": {
            "description": "Preset identificator.",
            "type": "integer",
            "x-api-allow": [
              "watcher-admin",
              "watcher-client"
            ]
          },
          "dvr": {
            "description": "DVR configuration.",
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_dvr_spec"
              }
            ],
            "x-api-allow": [
              "watcher-admin",
              "watcher-client"
            ]
          }
        }
      },
      "organization_stream": {
        "type": "object",
        "properties": {
          "id": {
            "description": "ID of the organization. Only organization owner or domain administrator could change it.\n",
            "type": "integer",
            "example": 9
          },
          "title": {
            "readOnly": true,
            "description": "Title of the organization.\n",
            "type": "string",
            "example": "Organization 1"
          }
        }
      },
      "watcher_stream_config": {
        "type": "object",
        "properties": {
          "created_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The date and time when the steam was created.",
            "example": 1672531199000,
            "readOnly": true,
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ],
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "organization_id": {
            "description": "ID of the organization the stream belongs to.\nOnly organization owner or domain administrator could change it.\n",
            "type": "integer",
            "example": 9,
            "deprecated": true,
            "x-delete-at": 25.11,
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ]
          },
          "organization": {
            "description": "Organization the stream belongs to.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/organization_stream"
              }
            ],
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ]
          },
          "is_favourite": {
            "description": "The stream is added to favorites list.",
            "type": "boolean",
            "x-api-allow": [
              "watcher-client"
            ]
          },
          "notifications_enabled": {
            "description": "Notifications are enabled for the camera.",
            "type": "boolean",
            "x-api-allow": [
              "watcher-client"
            ]
          },
          "coordinates": {
            "description": "Camera coordinates on a map or a floor plan.",
            "allOf": [
              {
                "$ref": "#/components/schemas/map_spec"
              }
            ],
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ]
          },
          "postal_address": {
            "description": "Camera adress on a map.",
            "type": "string",
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ]
          },
          "map_coordinates": {
            "description": "Camera coordinates on a map or a floor plan. Deprecated. Use coordinates instead.",
            "deprecated": true,
            "x-delete-at": 24.12,
            "x-alias": "coordinates",
            "allOf": [
              {
                "$ref": "#/components/schemas/map_spec"
              }
            ],
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ]
          },
          "onvif": {
            "description": "Onvif configuration",
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_onvif_config"
              }
            ]
          },
          "preset": {
            "description": "Preset settings.",
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_preset"
              }
            ],
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ]
          },
          "preset_id": {
            "description": "Preset identificator.",
            "deprecated": true,
            "x-delete-at": 26.01,
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ],
            "type": "integer"
          },
          "folder_id": {
            "description": "Folder identificator.",
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ],
            "type": "integer"
          },
          "audio": {
            "type": "object",
            "description": "Audio settings for the stream.",
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ],
            "properties": {
              "transcode_audio_codec": {
                "description": "Audio codec (the AAC codec is used by default).",
                "default": "aac",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/frame_audio_codec"
                  }
                ],
                "x-api-allow": [
                  "watcher-client",
                  "watcher-admin"
                ],
                "x-scope": [
                  "watcher-client",
                  "watcher-admin"
                ]
              },
              "disabled": {
                "type": "boolean",
                "example": false,
                "default": false,
                "description": "A flag showing if the audio is captured (false) or not (true) from the stream.\n",
                "x-api-allow": [
                  "watcher-client",
                  "watcher-admin"
                ],
                "x-scope": [
                  "watcher-client",
                  "watcher-admin"
                ]
              }
            }
          },
          "path": {
            "description": "Contains path to stream as a list.\nEach item of the list can be interpreted as a node in a folders tree.\n",
            "readOnly": true,
            "items": {
              "$ref": "#/components/schemas/stream_path_item"
            },
            "type": "array",
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ]
          },
          "firmware_update_duration": {
            "description": "Duration of the firmware update. If this field is present, the update process is ongoing.\n",
            "readOnly": true,
            "format": "milliseconds",
            "type": "integer",
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ],
            "x-format-description": "milliseconds"
          },
          "last_episode_at": {
            "type": "integer",
            "format": "utc_ms",
            "readOnly": true,
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ],
            "description": "The time when the last episode occurred.\n",
            "examples": {
              "default": {
                "value": 1637094994000
              }
            },
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "last_change": {
            "type": "object",
            "description": "Information about the latest changes made to the camera configuration.\n",
            "readOnly": true,
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/audit_log_record"
              }
            ]
          },
          "can_publish": {
            "description": "A publishable stream.",
            "type": "boolean",
            "example": false,
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ]
          }
        }
      },
      "streams_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "streams": {
                "items": {
                  "$ref": "#/components/schemas/stream_config"
                },
                "type": "array",
                "description": "List of fetched streams according to the query parameters."
              }
            }
          }
        ]
      },
      "stream_preset": {
        "type": "object",
        "properties": {
          "id": {
            "description": "Preset identificator.",
            "type": "integer"
          },
          "title": {
            "type": "string",
            "description": "Human-readable name of the preset.",
            "example": "Example preset name",
            "readOnly": true
          },
          "is_adjustable": {
            "type": "boolean",
            "description": "Shows if the preset is adjustable.\n```is_adjustable``` is needed for a situation where presets are managed by external billing. \nIf ```is_adjustable: true``` user can change camera settings meanwhile using this preset. \nIf ```is_adjustable: false``` user can not change camera settings meanwhile using this preset. \n\nIf the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied. \nIn this case, either make the preset adjustable, or change the preset itself to achieve the required configuration.\n",
            "readOnly": true,
            "example": true
          }
        }
      },
      "stream_onvif_config": {
        "type": "object",
        "properties": {
          "ptz": {
            "type": "boolean",
            "description": "Shows if PTZ control should be enabled for the camera. \nThe PTZ function must be supported and enabled on the ONVIF camera \nin order to be able to actually control PTZ from Watcher or your UI.\n"
          }
        }
      },
      "streams_import_response": {
        "type": "object",
        "properties": {
          "created": {
            "type": "integer",
            "description": "The number of streams created"
          },
          "updated": {
            "type": "integer",
            "description": "The number of streams updated"
          }
        }
      },
      "streams_multiedit_config": {
        "type": "object",
        "description": "Array of streams with settings",
        "properties": {
          "streams": {
            "type": "array",
            "description": "List of streams with their settings",
            "items": {
              "$ref": "#/components/schemas/stream_config_multiedit"
            }
          }
        }
      },
      "stream_path_item": {
        "type": "object",
        "properties": {
          "id": {
            "readOnly": true,
            "description": "ID of the path item the stream is included in.",
            "type": "integer"
          },
          "title": {
            "readOnly": true,
            "description": "Title of path item the stream is included in.",
            "type": "string"
          }
        }
      },
      "sensor": {
        "type": "object",
        "properties": {
          "brightness_correction": {
            "description": "Image brightness correction.\nThe value is indicated as a percentage from 0 to 100.\n",
            "type": "integer",
            "format": "percent",
            "minimum": 0,
            "maximum": 100,
            "x-api-allow": [
              "watcher-admin",
              "watcher-client"
            ],
            "x-format-description": "percent"
          },
          "contrast_correction": {
            "description": "Image contrast correction.\nThe value is indicated as a percentage from 0 to 100.\n",
            "type": "integer",
            "format": "percent",
            "minimum": 0,
            "maximum": 100,
            "x-api-allow": [
              "watcher-admin",
              "watcher-client"
            ],
            "x-format-description": "percent"
          },
          "sharpness": {
            "description": "Sharpness / edges contrast enhancement level.\nThe value is indicated as a percentage from 0 to 100.\n",
            "type": "integer",
            "format": "percent",
            "minimum": 0,
            "maximum": 100,
            "x-api-allow": [
              "watcher-admin",
              "watcher-client"
            ],
            "x-format-description": "percent"
          },
          "saturation": {
            "description": "Image saturation correction.\nThe value is indicated as a percentage from 0 to 100.\n",
            "type": "integer",
            "format": "percent",
            "minimum": 0,
            "maximum": 100,
            "x-api-allow": [
              "watcher-admin",
              "watcher-client"
            ],
            "x-format-description": "percent"
          },
          "wide_dynamic_range": {
            "description": "Image wide dynamic range correction.\nThe value is indicated as a percentage from 0 to 100.\n",
            "type": "integer",
            "format": "percent",
            "minimum": 0,
            "maximum": 100,
            "x-api-allow": [
              "watcher-admin",
              "watcher-client"
            ],
            "x-format-description": "percent"
          },
          "blacklight_compensation": {
            "description": "Image blacklight compensation correction",
            "allOf": [
              {
                "$ref": "#/components/schemas/on_off"
              }
            ],
            "x-api-allow": [
              "watcher-admin",
              "watcher-client"
            ]
          },
          "infrared_cutoff_filter": {
            "description": "Infrared cut-of filter",
            "allOf": [
              {
                "$ref": "#/components/schemas/on_off_auto"
              }
            ],
            "x-api-allow": [
              "watcher-admin",
              "watcher-client"
            ]
          },
          "image_orientation": {
            "description": "Installation position of the camera",
            "type": "string",
            "oneOf": [
              {
                "const": "normal",
                "title": "Normal",
                "description": "Default camera mount."
              },
              {
                "const": "upside_down",
                "title": "Upside down",
                "description": "Camera is mounted on the ceiling."
              }
            ],
            "x-api-allow": [
              "watcher-admin",
              "watcher-client"
            ]
          }
        }
      },
      "media_quality": {
        "oneOf": [
          {
            "const": "low",
            "title": "Low"
          },
          {
            "const": "medium",
            "title": "Medium"
          },
          {
            "const": "high",
            "title": "High"
          }
        ]
      },
      "firmware_update": {
        "type": "object",
        "description": "Update camera firmware",
        "properties": {
          "image": {
            "format": "binary",
            "description": "Image for updating camera. Documentation for updating cameras: https://flussonic.com/doc/flussonic-home-v1/#upgrade.\n",
            "example": "b'DL\u0003\u0004\u0014\u0000'",
            "x-format-description": "binary"
          },
          "proto": {
            "type": "string",
            "description": "Protocol for connecting to camera.",
            "oneOf": [
              {
                "title": "Iris",
                "const": "iris",
                "description": "Iris protocol"
              },
              {
                "title": "ISAPI/PSIA",
                "const": "isapi",
                "description": "ISAPI/PSIA protocol"
              },
              {
                "title": "Xm",
                "const": "xm",
                "description": "Xm protocol"
              },
              {
                "title": "MSTAR/Sputnik",
                "const": "sputnik",
                "description": "MSTAR/Sputnik protocol"
              }
            ],
            "default": "iris",
            "example": "iris"
          }
        },
        "required": [
          "image"
        ]
      },
      "auth": {
        "type": "object",
        "description": "Authentication details configuration",
        "properties": {
          "login": {
            "type": "string",
            "description": "Username authentication"
          },
          "password": {
            "type": "string",
            "description": "Password authentication"
          },
          "port": {
            "type": "integer",
            "description": "Service port on which Onvif/PSIA is accessible, default is 80"
          }
        }
      },
      "camera_config": {
        "type": "object",
        "properties": {
          "sensor": {
            "description": "Describes sensor configuration.\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/sensor"
              },
              {
                "$ref": "#/components/schemas/error_response"
              }
            ]
          },
          "camera_info": {
            "description": "Describes camera information.\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/camera_info"
              },
              {
                "$ref": "#/components/schemas/error_response"
              }
            ],
            "readOnly": true
          },
          "media_quality": {
            "description": "These parameters allow optimizing media quality and performance based on device capabilities and network conditions.\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/media_quality"
              },
              {
                "$ref": "#/components/schemas/error_response"
              }
            ]
          }
        }
      },
      "camera_info": {
        "type": "object",
        "description": "Camera information",
        "properties": {
          "firmware": {
            "type": "string",
            "description": "Firmware version"
          },
          "model": {
            "type": "string",
            "description": "Model name"
          },
          "manufacturer": {
            "type": "string",
            "description": "Manufacturer name"
          },
          "serial_number": {
            "type": "string",
            "description": "Serial number"
          }
        }
      },
      "thumbnails_spec": {
        "type": "object",
        "properties": {
          "enabled": {
            "description": "Whether to generate thumbnails from the video stream.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/thumbnails_enabled_spec"
              }
            ],
            "default": true
          }
        }
      },
      "map_spec": {
        "type": "object",
        "properties": {
          "latitude": {
            "description": "Geographic latitude.",
            "type": "number",
            "example": 55.7512
          },
          "longitude": {
            "description": "Geographic longitude.",
            "type": "number",
            "example": 37.6184
          }
        },
        "required": [
          "latitude",
          "longitude"
        ]
      },
      "login_info_base": {
        "type": "object",
        "properties": {
          "access_token": {
            "type": "string",
            "description": "A JWT token with a limited lifetime duration. JWT algorithm is RS256.\n",
            "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
          },
          "refresh_token": {
            "type": "string",
            "description": "A token used to get a new access_token after expiration.\nIt works with `/login` request only.\n",
            "example": "3637e790-5530-11ed-bdc3-0242ac120002"
          }
        }
      },
      "login_info_additional": {
        "allOf": [
          {
            "$ref": "#/components/schemas/login_info_base"
          },
          {
            "type": "object",
            "properties": {}
          }
        ]
      },
      "password_recovery": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "example": "user@example.com",
            "description": "Email address to which instructions will be sent\n",
            "x-format-description": "email"
          }
        }
      },
      "password_reset": {
        "type": "object",
        "properties": {
          "password": {
            "type": "string",
            "minLength": 5,
            "maxLength": 128,
            "description": "New password\n"
          }
        }
      },
      "vision_episode_face": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "preview"
            ],
            "properties": {
              "episode_type": {
                "type": "string",
                "description": "Face is detected",
                "const": "face"
              },
              "detections": {
                "type": "array",
                "description": "Detections associated with this episode",
                "items": {
                  "$ref": "#/components/schemas/vision_detected_face"
                }
              },
              "fingerprint": {
                "description": "The fingerprint of the detected face",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/vision_face_fingerprint"
                  }
                ]
              },
              "preview": {
                "type": "string",
                "contentEncoding": "base64",
                "format": "base64",
                "description": "Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.\n\nPreview contains an image of person's face and has a resolution about 200 x 200 pixels with maximum size about 10 kilobytes.\n",
                "x-format-description": "base64"
              },
              "matched_persons": {
                "description": "List of matched persons with similarity metric.  \nVideoanalytics identification service enriches episode's data and fills this field\nwith the list of persons that are similar to the face detected in this episode.\n",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/vision_person_match"
                }
              }
            }
          },
          {
            "$ref": "#/components/schemas/episode_base"
          }
        ]
      },
      "vision_episode_vehicle": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "preview"
            ],
            "description": "Vehicle episode",
            "properties": {
              "episode_type": {
                "type": "string",
                "description": "Vehicle is detected",
                "const": "vehicle"
              },
              "detections": {
                "type": "array",
                "description": "Detections associated with this episode",
                "items": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/vision_detected_vehicle"
                    },
                    {
                      "$ref": "#/components/schemas/vision_detected_license_plate"
                    }
                  ]
                }
              },
              "vehicle_purpose": {
                "description": "The purpose of the vehicle, e.g. emergency or regular.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/vision_vehicle_purpose"
                  }
                ]
              },
              "vehicle_emergency_subtype": {
                "description": "Emergency type of the vehicle.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/vision_vehicle_emergency_subtype"
                  }
                ]
              },
              "license_plate_text": {
                "description": "Recognized vehicle's license plate number",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/vision_license_plate_text"
                  }
                ]
              },
              "preview": {
                "type": "string",
                "contentEncoding": "base64",
                "format": "base64",
                "description": "Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.\n\nPreview contains an image of vehicle's license plate and has a resolution about 160 x 64 pixels with maximum size about 10 kilobytes.\n",
                "x-format-description": "base64"
              },
              "license_plate_missing": {
                "type": "boolean",
                "description": "Indicates if no license plate is detected on this vehicle"
              },
              "vehicle_facing_side": {
                "description": "Shows from which side the vehicle was detected.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/vision_vehicle_facing_side"
                  }
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/episode_base"
          }
        ]
      },
      "episode_play": {
        "type": "object",
        "properties": {
          "playback_token": {
            "type": "string",
            "description": "Temporary token for playback requests (Media Server Streaming API, Central Streaming API).",
            "example": "onetime_token"
          },
          "streaming_endpoint": {
            "description": "HTTP(s) URL that can be used for streaming API of this episode",
            "type": "string",
            "example": "https://streamer.example.com"
          }
        }
      },
      "episode_stream_details": {
        "type": "object",
        "properties": {
          "stream": {
            "description": "Details about stream related to the episode.",
            "type": "object",
            "required": [
              "name"
            ],
            "properties": {
              "name": {
                "type": "string",
                "format": "media_name",
                "description": "Globally unique stream name.\nNote that the name could not be changed after the stream is created.\n",
                "x-primary-key": true,
                "examples": {
                  "default": {
                    "value": "hockey1"
                  },
                  "mylive/bunny": {
                    "value": "mylive/bunny"
                  },
                  "decklink": {
                    "value": "Decklink-Stream"
                  },
                  "dektec": {
                    "value": "Dektec-Stream"
                  },
                  "test_stream": {
                    "value": "test_stream"
                  }
                },
                "x-format-description": "media_name"
              },
              "comment": {
                "description": "Human-readable description of the stream.\n",
                "type": "string",
                "example": "This is a test stream"
              },
              "title": {
                "description": "Human-readable title of the stream. Provided for SDT MPEG-TS table or\nSDP RTSP title parameter.\n",
                "type": "string",
                "example": "Hockey channel"
              },
              "organization_id": {
                "readOnly": true,
                "description": "ID of the organization the stream belongs to.\n",
                "type": "integer",
                "example": 9
              },
              "thumbnails": {
                "description": "Configuration of thumbnail of the stream.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/thumbnails_spec"
                  }
                ],
                "readOnly": true,
                "x-private": true
              }
            }
          }
        }
      },
      "episodes_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "episodes": {
                "description": "The list of Episodes fetched according to the query parameters.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/watcher_episode"
                }
              }
            }
          }
        ]
      },
      "episode_extra": {
        "type": "object",
        "properties": {
          "is_favorite": {
            "description": "Whether the episode is added to favorites.",
            "type": "boolean",
            "example": false,
            "readOnly": true
          },
          "title": {
            "type": "string",
            "description": "Optional title of the episode. Can be used to provide a human-readable name for the episode.\n",
            "maxLength": 64,
            "example": "Visitor at main entrance"
          },
          "description": {
            "type": "string",
            "description": "Optional description of the episode. Can be used to provide additional context or details about the episode.\n",
            "maxLength": 256,
            "example": "Person detected at the main entrance, stayed for 30 seconds"
          }
        }
      },
      "watcher_episode_base": {
        "type": "object",
        "description": "Base properties added by Watcher to all episode types",
        "allOf": [
          {
            "$ref": "#/components/schemas/episode_play"
          },
          {
            "$ref": "#/components/schemas/episode_extra"
          },
          {
            "$ref": "#/components/schemas/episode_stream_details"
          }
        ]
      },
      "watcher_episode": {
        "discriminator": {
          "propertyName": "episode_type",
          "mapping": {
            "generic": "#/components/schemas/watcher_episode_generic",
            "face": "#/components/schemas/watcher_episode_face",
            "vehicle": "#/components/schemas/watcher_episode_vehicle",
            "human": "#/components/schemas/watcher_episode_human",
            "context_search": "#/components/schemas/watcher_episode_context_search",
            "qr_code": "#/components/schemas/watcher_episode_qr_code",
            "custom": "#/components/schemas/watcher_episode_custom"
          }
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/watcher_episode_generic"
          },
          {
            "$ref": "#/components/schemas/watcher_episode_face"
          },
          {
            "$ref": "#/components/schemas/watcher_episode_vehicle"
          },
          {
            "$ref": "#/components/schemas/watcher_episode_human"
          },
          {
            "$ref": "#/components/schemas/watcher_episode_context_search"
          },
          {
            "$ref": "#/components/schemas/watcher_episode_qr_code"
          },
          {
            "$ref": "#/components/schemas/watcher_episode_custom"
          }
        ]
      },
      "watcher_episode_generic": {
        "allOf": [
          {
            "$ref": "#/components/schemas/episode_generic"
          },
          {
            "$ref": "#/components/schemas/watcher_episode_base"
          }
        ]
      },
      "watcher_episode_face": {
        "allOf": [
          {
            "$ref": "#/components/schemas/vision_episode_face"
          },
          {
            "$ref": "#/components/schemas/watcher_episode_base"
          }
        ]
      },
      "watcher_episode_vehicle": {
        "allOf": [
          {
            "$ref": "#/components/schemas/vision_episode_vehicle"
          },
          {
            "$ref": "#/components/schemas/watcher_episode_base"
          }
        ]
      },
      "watcher_episode_human": {
        "allOf": [
          {
            "$ref": "#/components/schemas/vision_episode_human"
          },
          {
            "$ref": "#/components/schemas/watcher_episode_base"
          }
        ]
      },
      "watcher_episode_context_search": {
        "allOf": [
          {
            "$ref": "#/components/schemas/vision_episode_context_search"
          },
          {
            "$ref": "#/components/schemas/watcher_episode_base"
          }
        ]
      },
      "watcher_episode_qr_code": {
        "allOf": [
          {
            "$ref": "#/components/schemas/vision_episode_qr_code"
          },
          {
            "$ref": "#/components/schemas/watcher_episode_base"
          }
        ]
      },
      "watcher_episode_custom": {
        "allOf": [
          {
            "$ref": "#/components/schemas/episode_custom"
          },
          {
            "$ref": "#/components/schemas/watcher_episode_base"
          }
        ]
      },
      "profile": {
        "allOf": [
          {
            "$ref": "#/components/schemas/user_base"
          },
          {
            "$ref": "#/components/schemas/user_profile"
          },
          {
            "type": "object",
            "description": "Users apikey for access via API.\n",
            "properties": {
              "apikey": {
                "type": "string",
                "readOnly": true,
                "description": "Apikey for users access via API.\n"
              }
            }
          }
        ]
      },
      "apikey": {
        "type": "object",
        "description": "Users apikey for access via API.\n",
        "properties": {
          "apikey": {
            "type": "string",
            "description": "Apikey for users access via API.\n"
          }
        }
      },
      "web_push_subscription": {
        "type": "object",
        "description": "WebPush Notifications subscription",
        "required": [
          "endpoint"
        ],
        "properties": {
          "endpoint": {
            "type": "string",
            "format": "uri",
            "description": "Endpoint on which Billing will send Push Messages",
            "example": "https://fcm.googleapis.com/fcm/send/${token}",
            "x-format-description": "uri"
          }
        },
        "externalDocs": "https://developer.mozilla.org/en-US/docs/Web/API/Push_API"
      },
      "web_push_subscription_create": {
        "allOf": [
          {
            "$ref": "#/components/schemas/web_push_subscription"
          },
          {
            "type": "object",
            "required": [
              "keys"
            ],
            "properties": {
              "keys": {
                "type": "object",
                "description": "Keys that are used to encrypt the payload",
                "required": [
                  "p256dh",
                  "auth"
                ],
                "writeOnly": true,
                "properties": {
                  "p256dh": {
                    "type": "string",
                    "description": "Public key",
                    "minLength": 1
                  },
                  "auth": {
                    "type": "string",
                    "description": "Authentication secret",
                    "minLength": 1
                  }
                }
              }
            }
          }
        ]
      },
      "persons_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "required": [
              "persons"
            ],
            "properties": {
              "persons": {
                "description": "List of fetched persons according to the query parameters.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/vision_person"
                }
              }
            }
          }
        ]
      },
      "person": {
        "type": "object",
        "description": "Person",
        "required": [
          "person_id",
          "updated_at",
          "originator"
        ],
        "properties": {
          "person_id": {
            "description": "Identifier of the person",
            "readOnly": true,
            "format": "snowflake_id",
            "type": "integer",
            "examples": {
              "default": {
                "value": 7036001172460667000
              }
            },
            "x-format-description": "snowflake_id"
          },
          "name": {
            "type": "string",
            "description": "The name of the person filled in manually or automatically if not recognized\n",
            "examples": {
              "default": {
                "value": "John Doe"
              },
              "unknown": {
                "value": "Unknown ABC"
              }
            }
          },
          "external_id": {
            "description": "Identifier of the person in the external system. \nUse it when supplying the recognition results further into the external system\n(e.g. for access level check) if the person identifiers in the external system \nare different from the ones in Flussonic Identification database.\n\nThis field may contain `null` when video analytics detects a new person\nwhich explicitly has no association in the external system (i.e. if `originator=identification_service`). \n",
            "type": "string",
            "examples": {
              "default": {
                "value": "dedcc8e8"
              }
            }
          },
          "originator": {
            "description": "Indicates the way this person was created: \nmanually via an api or automatically in the identification service.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_person_originator"
              }
            ]
          },
          "updated_at": {
            "description": "When this person was last updated",
            "type": "integer",
            "format": "utc_ms",
            "example": 1637034282845,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "deleted_at": {
            "description": "When this person was marked as deleted",
            "type": "integer",
            "format": "utc_ms",
            "example": 1637095014573,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "photos": {
            "description": "Person's photos. External system uploads images\nwhich are being processed by videoanalytics\nto get digital fingerprint of the person\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/vision_image_attributes"
            }
          },
          "organization": {
            "description": "Organization information.",
            "allOf": [
              {
                "$ref": "#/components/schemas/organization_base"
              }
            ]
          },
          "person_list": {
            "description": "Person list details",
            "type": "object",
            "properties": {
              "id": {
                "type": "integer",
                "description": "Person list identifier",
                "example": 3
              },
              "name": {
                "type": "string",
                "description": "Person list name",
                "example": "List 1"
              }
            }
          },
          "first_seen_at": {
            "description": "When this person was first seen",
            "type": "integer",
            "format": "utc_ms",
            "example": 1637034282845,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "last_seen_at": {
            "description": "When this person was last seen",
            "type": "integer",
            "format": "utc_ms",
            "example": 1637095014573,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          }
        }
      },
      "vision_person_originator": {
        "type": "string",
        "oneOf": [
          {
            "title": "api",
            "const": "api",
            "description": "Person is created by operator or external system via API.\nFor example, when you add the person in Watcher UI, it has `originator=api`.\nBut when you edit an automatically created person in UI, `originator=identification_service` remains.\n"
          },
          {
            "title": "identification_service",
            "const": "identification_service",
            "description": "Person is created automatically by the Identification service\nbecause no matching person was found in the persons database.\n\nThe Identification service stores unrecognized persons and matches new episodes with them\nin case if it becomes known who this is (i.e. if operator edits such person in UI to specify name).\n"
          }
        ]
      },
      "vision_image_attributes": {
        "type": "object",
        "required": [
          "data"
        ],
        "properties": {
          "data": {
            "description": "Base64-encoded image data",
            "type": "string",
            "format": "base64",
            "x-format-description": "base64"
          },
          "sha256": {
            "type": "string",
            "format": "hexbinary",
            "description": "Checksum of this image",
            "minLength": 64,
            "maxLength": 64,
            "x-format-description": "hexbinary"
          },
          "mime_type": {
            "description": "MIME type of the image",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_image_mimetype"
              }
            ]
          }
        }
      },
      "person_lists_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "person_lists": {
                "items": {
                  "$ref": "#/components/schemas/person_lists"
                },
                "type": "array",
                "description": "List of fetched person lists according to the query parameters."
              }
            }
          }
        ]
      },
      "person_lists": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "id": {
                "description": "Identifier of the person list.\n",
                "type": "integer",
                "example": 1
              },
              "name": {
                "description": "The person list name.\n",
                "type": "string",
                "example": "List 1"
              },
              "organization": {
                "description": "Organization information.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/organization_base"
                  }
                ]
              },
              "stats": {
                "type": "object",
                "description": "Counts elements in a list based on specific attributes.",
                "properties": {
                  "person": {
                    "description": "The number of person in the person list.\n",
                    "type": "integer",
                    "example": 1
                  },
                  "camera": {
                    "description": "The number of camera in the person list.\n",
                    "type": "integer",
                    "example": 1
                  }
                }
              }
            }
          }
        ],
        "required": [
          "id",
          "name"
        ]
      },
      "users": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "users_list": {
                "items": {
                  "$ref": "#/components/schemas/user"
                },
                "type": "array",
                "description": "List of fetched users according to the query parameters."
              }
            }
          }
        ]
      },
      "user": {
        "allOf": [
          {
            "$ref": "#/components/schemas/user_base"
          },
          {
            "$ref": "#/components/schemas/user_admin"
          }
        ]
      },
      "user_create": {
        "allOf": [
          {
            "$ref": "#/components/schemas/user"
          },
          {
            "type": "object",
            "title": "organization_id",
            "properties": {
              "organization_id": {
                "description": "The identifier of the Organization to which the user should be added.\nIf no organization_id - first organization where user has permissions for managing users.\n",
                "x-api-description": {
                  "watcher-client": "The identifier of the Organization to which the user should be added.\nIf no organization_id - first organization where user has permissions for managing users.\n",
                  "watcher-admin": "The identifier of the Organization to which the user should be added.\nIf no organization_id - default organization should be used.\n"
                },
                "type": "integer",
                "example": 12
              }
            }
          }
        ]
      },
      "user_base": {
        "type": "object",
        "description": "User parameters visible from Admin and Client APIs.\n",
        "properties": {
          "name": {
            "type": "string",
            "description": "User name (login)\n"
          },
          "fullname": {
            "type": "string",
            "description": "The user's full name.   \n"
          },
          "password": {
            "type": "string",
            "writeOnly": true,
            "description": "The specified password will be saved as a hash, used only for writing\n"
          },
          "email": {
            "type": "string",
            "format": "email",
            "example": "user@example.com",
            "description": "User's email. Required for password recovery.\n",
            "x-format-description": "email"
          },
          "phone": {
            "type": "string",
            "format": "phone-number",
            "example": "+78007778413",
            "description": "User's phone number\n",
            "x-format-description": "phone-number"
          },
          "locale": {
            "description": "The language, selected by user.",
            "type": "string",
            "format": "ISO 639-1",
            "example": "en"
          },
          "note": {
            "type": "string",
            "description": "Additional information or notes about the user.\n"
          },
          "max_sessions": {
            "type": "integer",
            "description": "The maximum number of sessions the user can have simultaneously.\n"
          },
          "created_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The date and time when the user was created.\n",
            "readOnly": true,
            "example": 1672531199000,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          }
        }
      },
      "user_profile": {
        "type": "object",
        "description": "User parameters visible from Admin and Client APIs.\n",
        "properties": {
          "is_admin": {
            "type": "boolean",
            "readOnly": true,
            "description": "Indicates that user has access_level equal \"admin\".\n"
          },
          "is_domain_admin": {
            "type": "boolean",
            "readOnly": true,
            "description": "Indicates that user has access_level equal \"domain admin\".\n"
          },
          "is_readonly": {
            "type": "boolean",
            "readOnly": true,
            "description": "Indicates that the user has a read-only access level.\n",
            "example": true
          }
        }
      },
      "user_admin": {
        "type": "object",
        "description": "User Parameters available from Admin API.\n",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Identifier of the user.\n",
            "readOnly": true,
            "example": 1,
            "x-primary-key": true
          },
          "disabled": {
            "type": "boolean",
            "default": false,
            "description": "A parameter that allows you to enable/disable the user\n",
            "example": false
          },
          "readonly": {
            "type": "boolean",
            "description": "A flag indicating that the user has read-only access and cannot modify their own data.\n",
            "example": false
          },
          "organizations": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "integer",
                  "description": "Id of the organization\n",
                  "example": 1
                },
                "title": {
                  "type": "string",
                  "description": "Display title of the organization\n",
                  "example": "Cameras"
                },
                "owner": {
                  "type": "object",
                  "description": "Owner properties.",
                  "properties": {
                    "id": {
                      "type": "integer",
                      "description": "ID of the organizations owner.",
                      "example": 2
                    },
                    "name": {
                      "type": "string",
                      "description": "Name of the organizations owner.",
                      "example": "admin",
                      "readOnly": true
                    }
                  }
                },
                "permissions": {
                  "description": "Organization permissions",
                  "readOnly": true,
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/organization_permissions"
                    }
                  ]
                }
              }
            },
            "readOnly": true,
            "description": "A parameter indicating that the user belongs to certain organizations\n"
          },
          "access_level": {
            "type": "string",
            "oneOf": [
              {
                "const": "generic",
                "description": "Defines standard rights for the user (access is allowed only in the client ui and\nview of those cameras to which access is granted explicitly)\n"
              },
              {
                "const": "admin",
                "description": "Grants full rights (allows you to create organizations,\nuse both admin ui and client ui, change domain settings)\n"
              }
            ],
            "default": "generic",
            "description": "The parameter regulates the rights for the user\n",
            "example": "generic"
          }
        }
      },
      "user_folder": {
        "allOf": [
          {
            "$ref": "#/components/schemas/folder"
          },
          {
            "type": "object",
            "properties": {
              "permissions": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/folder_user"
                  },
                  {
                    "type": "object",
                    "description": "Additional permissions for the folder"
                  }
                ]
              }
            }
          }
        ]
      },
      "user_folders": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "folders": {
                "type": "array",
                "description": "List of fetched user folders according to the query parameters.",
                "items": {
                  "$ref": "#/components/schemas/user_folder"
                }
              }
            }
          }
        ]
      },
      "message_send": {
        "allOf": [
          {
            "$ref": "#/components/schemas/message_base"
          },
          {
            "type": "object",
            "properties": {
              "user_id": {
                "type": "integer",
                "description": "Identifier of the user to whom the message will be sent.\n",
                "example": 1
              }
            }
          }
        ],
        "required": [
          "user_id",
          "body"
        ]
      },
      "message_base": {
        "type": "object",
        "description": "The message that will be sent to the user.\n",
        "properties": {
          "title": {
            "type": "string",
            "description": "Message title.\n",
            "example": "Attention! Maintenance work is in progress.\n"
          },
          "body": {
            "type": "string",
            "description": "Message text with Markdown.\n",
            "example": "**Maintenance work is in progress.**\n"
          },
          "type": {
            "type": "string",
            "oneOf": [
              {
                "const": "info",
                "description": "The info message type.\n"
              },
              {
                "const": "warning",
                "description": "The warning message type.\n"
              },
              {
                "const": "danger",
                "description": "The danger message type.\n"
              }
            ],
            "description": "The type of a message.\n",
            "example": "warning"
          },
          "is_push": {
            "type": "boolean",
            "default": false,
            "description": "Whether to send a push notification to mobile devices or not\n",
            "example": false
          },
          "is_dashboard": {
            "type": "boolean",
            "default": false,
            "description": "Whether to display the notification on the information panel or not\n",
            "example": false
          }
        }
      },
      "message": {
        "allOf": [
          {
            "$ref": "#/components/schemas/message_base"
          },
          {
            "type": "object",
            "properties": {
              "id": {
                "type": "integer",
                "description": "Identifier of the message.\n",
                "readOnly": true,
                "example": 1
              },
              "is_deleted": {
                "type": "boolean",
                "default": false,
                "description": "This parameter indicates whether the message is deleted or not.\n",
                "example": false
              },
              "sender": {
                "type": "object",
                "description": "Message sender\n",
                "properties": {
                  "id": {
                    "type": "integer",
                    "description": "User ID who sent the message\n",
                    "example": 1
                  },
                  "name": {
                    "type": "string",
                    "description": "User name who sent the message\n",
                    "example": "admin"
                  }
                }
              },
              "user": {
                "type": "object",
                "description": "Message recipient\n",
                "properties": {
                  "id": {
                    "type": "integer",
                    "description": "User ID to whom the message was sent\n",
                    "example": 1
                  },
                  "name": {
                    "type": "string",
                    "description": "User name to whom the message was sent\n",
                    "example": "support"
                  }
                }
              },
              "was_read": {
                "type": "boolean",
                "default": false,
                "description": "This parameter indicates whether the message has been read or not.\n",
                "example": false
              }
            }
          }
        ]
      },
      "messages": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "messages": {
                "items": {
                  "$ref": "#/components/schemas/message"
                },
                "type": "array",
                "description": "List of fetched messages according to the query parameters."
              }
            }
          }
        ]
      },
      "message_response": {
        "allOf": [
          {
            "$ref": "#/components/schemas/message"
          },
          {
            "type": "object",
            "properties": {
              "devices": {
                "type": "integer",
                "description": "The number of devices to which push notifications were sent. If the flag `is_push` is set to `true` and no devices are returned,\nit means the user has no devices registered for push notifications.\n",
                "readOnly": true,
                "example": 3
              }
            }
          }
        ]
      },
      "message_change_request": {
        "allOf": [
          {
            "$ref": "#/components/schemas/message_base"
          },
          {
            "type": "object",
            "properties": {
              "was_read": {
                "type": "boolean",
                "default": false,
                "description": "This parameter indicates whether the message has been read or not.\n",
                "example": false
              }
            }
          }
        ]
      },
      "agent_activation_token": {
        "required": [
          "token"
        ],
        "properties": {
          "token": {
            "type": "string",
            "description": "Agent activation token.\n"
          },
          "stream_name": {
            "type": "string",
            "description": "A unique stream name. Its presence notifies about the binding of the agent token to the stream.\n"
          }
        }
      },
      "agent_activation_token_request": {
        "properties": {
          "title": {
            "type": "string",
            "description": "Human readable title of the camera as displayed in the UI. If not specified, title will be automatically generated.\n"
          },
          "organization_id": {
            "type": "integer",
            "description": "The identifier of the Organization to which the camera belongs.\nThe user activating the camera must have the right to control the cameras in this organization.\nIf user belongs to only one organization, camera will be automatically added to this organization.\nIf user belongs to multiple organizations, this parameter is required.\n"
          },
          "preset_id": {
            "type": "integer",
            "description": "The identifier of the preset assigned to the camera.\nIf this parameter is not specified, the camera will be added with default preset.\n"
          },
          "folder_id": {
            "type": "integer",
            "description": "The identifier of a folder to which the camera is added.\n"
          },
          "enabled": {
            "type": "boolean",
            "description": "Shows if the camera enabled or not. If the camera is enabled (the parameter is true), video from it is captured by the streamer.\n"
          },
          "static": {
            "type": "boolean",
            "description": "If true, the video is captured continuously; if false, the camera is in \"On-demand\" mode.\n"
          },
          "dvr_depth": {
            "type": "integer",
            "description": "The archive depth for the camera (the number of days).\n",
            "minimum": 0
          },
          "dvr_space": {
            "type": "integer",
            "description": "The maximum storage space for the camera's archive, in Gigabytes.\n",
            "minimum": 0
          },
          "comment": {
            "type": "string",
            "description": "Any text note about the camera.\n"
          },
          "coordinates": {
            "type": "object",
            "allOf": [
              {
                "$ref": "#/components/schemas/coordinates"
              }
            ]
          },
          "postal_address": {
            "type": "string",
            "description": "The postal address of the camera.\n"
          }
        }
      },
      "organization_base": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "readOnly": true,
            "description": "Organization identifier.",
            "example": 7,
            "x-primary-key": true
          },
          "title": {
            "type": "string",
            "description": "Human-readable name of the organization.",
            "example": "Example LLC"
          }
        },
        "required": [
          "id",
          "title"
        ]
      },
      "organization": {
        "allOf": [
          {
            "$ref": "#/components/schemas/organization_base"
          },
          {
            "type": "object",
            "properties": {
              "stats": {
                "type": "object",
                "description": "Counts for streams, users and mosaics in organization.",
                "readOnly": true,
                "properties": {
                  "streams": {
                    "type": "integer",
                    "description": "Count of streams in organization.",
                    "example": 12
                  },
                  "users": {
                    "type": "integer",
                    "description": "Count of users in organization.",
                    "example": 12
                  },
                  "mosaics": {
                    "type": "integer",
                    "description": "Count of mosaics in organization.",
                    "example": 2
                  }
                }
              },
              "limits": {
                "type": "object",
                "description": "Limits for properties in organization.",
                "properties": {
                  "streams": {
                    "type": "integer",
                    "description": "Streams limit in organization. Maximum amount of streams for organization.",
                    "example": 50,
                    "default": 5000
                  },
                  "users": {
                    "type": "integer",
                    "description": "Owner cannot add users above this limit.",
                    "example": 50,
                    "default": 2000
                  }
                }
              },
              "is_default": {
                "type": "boolean",
                "description": "Is that organization is default for new users.",
                "readOnly": true,
                "example": true
              },
              "owner": {
                "type": "object",
                "description": "Owner properties.",
                "properties": {
                  "id": {
                    "type": "integer",
                    "description": "ID of the organizations owner.",
                    "example": 2
                  },
                  "name": {
                    "type": "string",
                    "description": "Name of the organizations owner.",
                    "example": "admin",
                    "readOnly": true
                  }
                }
              },
              "user_permissions": {
                "description": "User permissions in organization.",
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/organization_permissions"
                  }
                ],
                "readOnly": true
              },
              "created_at": {
                "type": "integer",
                "format": "utc_ms",
                "description": "The date and time when the organization was created.\n",
                "example": 1672531199000,
                "readOnly": true,
                "x-format-description": "Unix timestamp in milliseconds",
                "minimum": 1000000000000,
                "maximum": 10000000000000
              },
              "pickpoint": {
                "description": "Pickpoint properties.",
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/organization_pickpoint"
                  }
                ]
              }
            }
          }
        ]
      },
      "organizations_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "organizations": {
                "items": {
                  "$ref": "#/components/schemas/organization"
                },
                "type": "array",
                "description": "List of organizations."
              }
            }
          }
        ]
      },
      "organization_permissions": {
        "type": "object",
        "properties": {
          "is_member": {
            "type": "boolean",
            "description": "Is the user a member of the organization.",
            "example": true,
            "readOnly": true
          },
          "can_view_stats": {
            "type": "boolean",
            "description": "An indicator of whether the user can view statistics of organization.",
            "example": true
          },
          "can_edit_streams": {
            "type": "boolean",
            "description": "An indicator of whether the user has control over the streams.",
            "example": true
          },
          "can_edit_users": {
            "type": "boolean",
            "description": "An indicator of whether the user has control over the users.",
            "example": true
          },
          "can_view_persons_lists": {
            "type": "boolean",
            "description": "An indicator of whether the user can view persons list in organization.",
            "example": true
          },
          "can_edit_persons_lists": {
            "type": "boolean",
            "description": "An indicator of whether the user has control over the persons list in organization.",
            "example": true
          },
          "can_view_streams": {
            "type": "boolean",
            "description": "An indicator of whether the user can view the streams.",
            "example": true
          }
        }
      },
      "organization_user": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "User identifier",
            "example": 7,
            "readOnly": true
          },
          "name": {
            "type": "string",
            "description": "User name",
            "example": "Example LLC",
            "readOnly": true
          },
          "email": {
            "type": "string",
            "description": "User email",
            "example": "user@example.com",
            "readOnly": true
          },
          "permissions": {
            "type": "object",
            "description": "User permissions",
            "properties": {
              "folders": {
                "description": "List of permissions in [Folders](https://flussonic.com/doc/api/watcher-client/#tag/folder)",
                "type": "array",
                "readOnly": true,
                "items": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "id": {
                          "type": "integer",
                          "description": "Id of [Folder](https://flussonic.com/doc/api/watcher-client/#tag/folder)"
                        }
                      }
                    },
                    {
                      "$ref": "#/components/schemas/folder_user"
                    }
                  ]
                }
              },
              "organization": {
                "type": "object",
                "description": "User permissions in [Organization](https://flussonic.com/doc/api/watcher-client/#tag/organization)\n",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/organization_permissions"
                  }
                ]
              }
            }
          }
        }
      },
      "organization_users_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "users": {
                "items": {
                  "$ref": "#/components/schemas/organization_user"
                },
                "type": "array",
                "description": "List of users in organizations."
              }
            }
          }
        ]
      },
      "organization_preset": {
        "type": "object",
        "properties": {
          "preset_id": {
            "type": "integer",
            "description": "Preset identifier",
            "example": 7
          }
        }
      },
      "organization_pickpoint": {
        "type": "object",
        "properties": {}
      },
      "organization_invite_key": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "invite_key": {
                "type": "string",
                "description": "Unique invitation key that can be used to invite users to the organization."
              }
            }
          },
          {
            "$ref": "#/components/schemas/organization_invite_setup"
          }
        ]
      },
      "organization_invite_setup": {
        "type": "object",
        "properties": {
          "permissions": {
            "description": "User permissions in organization.",
            "type": "object",
            "properties": {
              "can_view_stats": {
                "type": "boolean",
                "description": "An indicator of whether the user can view statistics of organization."
              },
              "can_edit_streams": {
                "type": "boolean",
                "description": "An indicator of whether the user has control over the streams."
              },
              "can_view_streams": {
                "type": "boolean",
                "description": "An indicator of whether the user can view the streams."
              },
              "can_edit_users": {
                "type": "boolean",
                "description": "An indicator of whether the user has control over the users."
              }
            }
          }
        }
      },
      "floor_file": {
        "type": "object",
        "description": "Floor file object",
        "properties": {
          "b64_content": {
            "description": "Image data in base64 format",
            "writeOnly": true,
            "title": "b64_content",
            "type": "string"
          },
          "binary_content": {
            "description": "Image data in binary format",
            "writeOnly": true,
            "title": "binary_content",
            "type": "string"
          },
          "mime_type": {
            "description": "Mime type of the image",
            "writeOnly": true,
            "title": "mime_type",
            "type": "string"
          },
          "url": {
            "description": "Image URL",
            "readOnly": true,
            "title": "url",
            "type": "string",
            "deprecated": true,
            "x-delete-at": 25.09
          },
          "name": {
            "description": "File name",
            "readOnly": true,
            "title": "name",
            "type": "string",
            "example": "1-maps-2_07957af5f132243350a0f5546a675cb006354b69"
          }
        }
      },
      "folder": {
        "type": "object",
        "properties": {
          "id": {
            "readOnly": true,
            "type": "integer",
            "description": "The folder ID.\n"
          },
          "streams_count": {
            "type": "integer",
            "readOnly": true,
            "example": 2,
            "description": "The number of streams in the folder.\n"
          },
          "coordinates": {
            "description": "The folder may have a floor plan attached to it to be shown on the map.\nThis parameter sets the image center coordinates: latitude and longitude.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/map_spec"
              }
            ]
          },
          "floor_plan": {
            "type": "object",
            "description": "Object of map parameters",
            "properties": {
              "file": {
                "$ref": "#/components/schemas/floor_file"
              },
              "bottomleft": {
                "description": "The coordinates of the bottom left corner of the floor plan image.\n",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/map_spec"
                  }
                ]
              },
              "topleft": {
                "description": "The coordinates of the top left corner of the floor plan image.\n",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/map_spec"
                  }
                ]
              },
              "topright": {
                "description": "The coordinates of the top right corner of the floor plan image.\n",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/map_spec"
                  }
                ]
              }
            }
          },
          "hierarchy": {
            "type": "object",
            "description": "Hierarchy object.",
            "properties": {
              "level": {
                "readOnly": true,
                "type": "integer",
                "description": "The folder level in the hierarchy. The default (main) folder of the Organization is level 0.\nThe child folder of the default folder is level 1, etc.\n"
              },
              "order_num": {
                "readOnly": true,
                "type": "integer",
                "description": "The index number of the folder within the parent folder. This number can be used for ordering folders.\n"
              },
              "shift": {
                "type": "object",
                "description": "This parameters block allows changing the level of the folder in the hierarchy and order of folders",
                "writeOnly": true,
                "properties": {
                  "direction": {
                    "type": "string",
                    "oneOf": [
                      {
                        "const": "after",
                        "title": "after",
                        "description": "This parameter allows changing the folders order set by `order_num` without re-numbering all folders manually.\nJust specify the ID of the folder (on the same level within the parent folder) to place the current folder after.\nWatcher will rearrange the order numbers automatically.\n\nYou can use `shift_before` parameter instead depending on your situation. \n"
                      },
                      {
                        "const": "before",
                        "title": "before",
                        "description": "This parameter allows changing the folders order set by `order_num` without re-numbering all folders manually.\nJust specify the ID of the folder (on the same level within the parent folder) to place the current folder before.\nWatcher will rearrange the order numbers automatically.\n\nYou can use `shift_after` parameter instead depending on your situation.\n"
                      },
                      {
                        "const": "inside",
                        "title": "inside",
                        "description": "This parameter allows changing the level of the folder in the hierarchy. \nSpecify the parent folder ID to place the current folder under it.\n"
                      }
                    ]
                  },
                  "destination": {
                    "description": "The Id of destination folder.",
                    "type": "integer"
                  }
                }
              }
            }
          },
          "organization_id": {
            "readOnly": true,
            "type": "integer",
            "description": "The identifier of the Organization to which the folder belongs.\n"
          },
          "parent_id": {
            "type": "integer",
            "title": "parent_id",
            "description": "The identifier of the parent folder.\n"
          },
          "title": {
            "type": "string",
            "description": "The folder name.\n"
          }
        },
        "required": [
          "id"
        ]
      },
      "folders_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "folders": {
                "items": {
                  "$ref": "#/components/schemas/folder"
                },
                "type": "array",
                "description": "List of folders."
              }
            }
          }
        ]
      },
      "folder_users_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "users": {
                "items": {
                  "$ref": "#/components/schemas/folder_users"
                },
                "type": "array",
                "description": "List of fetched users in a folder according to the query parameters."
              }
            }
          }
        ]
      },
      "folder_users": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "user_id": {
                "type": "integer",
                "description": "User identifier",
                "readOnly": true
              }
            }
          },
          {
            "$ref": "#/components/schemas/folder_user"
          }
        ],
        "required": [
          "user_id"
        ]
      },
      "folder_user": {
        "type": "object",
        "properties": {
          "can_view": {
            "type": "boolean",
            "default": false,
            "description": "The flag showing if the user can view only live on the streams in the folder and the list of streams."
          },
          "can_view_dvr": {
            "type": "boolean",
            "default": false,
            "description": "The flag showing if the user can view archive on the streams in the folder."
          },
          "dvr_depth_limit": {
            "type": "integer",
            "format": "seconds",
            "minimum": 0,
            "description": "The dvr depth limit allows to:\nSet the maximum recording depth, which determines how far back recorded materials can be viewed.\nManage access to archived data, ensuring security and control over who can access records.\nif set to 0, the user has unlimited access to the archive.\n",
            "example": 3600,
            "x-format-description": "seconds"
          },
          "can_use_ptz": {
            "type": "boolean",
            "default": false,
            "description": "The flag if the user can use PTZ controls."
          },
          "can_use_actions": {
            "type": "boolean",
            "default": false,
            "description": "The flag showing if the user can manage and execute actions on the streams in the folder."
          }
        }
      },
      "preset": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "readOnly": true,
            "description": "Preset identifier",
            "example": 7
          },
          "title": {
            "type": "string",
            "description": "Human-readable name of the preset.",
            "example": "Example preset name"
          },
          "is_adjustable": {
            "type": "boolean",
            "description": "Shows if the preset is adjustable.\n```is_adjustable``` is needed for a situation where presets are managed by external billing. \nIf ```is_adjustable: true``` user can change camera settings meanwhile using this preset. \nIf ```is_adjustable: false``` user can not change camera settings meanwhile using this preset. \n\nIf the camera has a non-adjustable presets, the DVR and analytics parameters from PUT requests will not be applied. \nIn this case, either make the preset adjustable, or change the preset itself to achieve the required configuration. \n",
            "default": true,
            "example": true
          },
          "dvr": {
            "description": "DVR configuration",
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_dvr_spec"
              }
            ]
          },
          "vision": {
            "description": "Vision configuration",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_spec_presets"
              }
            ]
          },
          "is_default": {
            "type": "boolean",
            "description": "Shows if the preset is available in all Organizations.\n",
            "x-api-description": "watcher-client: This field has to be readonly, clients have no rights to manage this field\n"
          },
          "stats": {
            "type": "object",
            "description": "Statistics of the preset.",
            "readOnly": true,
            "properties": {
              "streams_count": {
                "type": "integer",
                "description": "Count of streams are currently using this preset.",
                "example": 12
              },
              "organizations_count": {
                "type": "integer",
                "description": "Count of organizations are currently using this preset.",
                "example": 12
              }
            }
          },
          "last_change": {
            "type": "object",
            "description": "Information about the latest changes made to the preset configuration.",
            "allOf": [
              {
                "$ref": "#/components/schemas/preset_last_change"
              }
            ],
            "readOnly": true
          }
        },
        "required": [
          "id",
          "title"
        ]
      },
      "presets_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "presets": {
                "items": {
                  "$ref": "#/components/schemas/preset"
                },
                "type": "array",
                "description": "List of presets."
              }
            }
          }
        ]
      },
      "coordinates": {
        "type": "object",
        "description": "The camera geographic coordinates: latitude and longitude.\n",
        "properties": {
          "latitude": {
            "type": "float",
            "description": "Latitude."
          },
          "longitude": {
            "type": "float",
            "description": "Longitude."
          }
        }
      },
      "device_token": {
        "type": "object",
        "description": "Generated with firebase token",
        "required": [
          "token"
        ],
        "properties": {
          "token": {
            "description": "Device token. You can read how to create it here: https://firebase.google.com/docs/cloud-messaging/android/client?hl=en#sample-register\n",
            "title": "token",
            "type": "string",
            "readOnly": true
          },
          "device": {
            "$ref": "#/components/schemas/device_info"
          }
        }
      },
      "subscription_request": {
        "properties": {
          "stream_name": {
            "description": "stream identificator",
            "title": "stream_name",
            "type": "string"
          },
          "event_types": {
            "description": "Choosing which type of events to subscribe to",
            "type": "object",
            "properties": {
              "episode_generic": {
                "description": "Generic episode",
                "type": "boolean",
                "example": true
              },
              "episode_vehicle": {
                "description": "Vehicle episode",
                "type": "boolean",
                "example": false
              },
              "episode_face": {
                "description": "Face episode",
                "type": "boolean",
                "example": true
              }
            }
          },
          "notification_type": {
            "description": "Type of notification",
            "title": "notification_type",
            "type": "string",
            "enum": [
              "push"
            ]
          }
        },
        "required": [
          "event_types",
          "notification_type",
          "stream_name"
        ],
        "type": "object"
      },
      "subscription": {
        "allOf": [
          {
            "$ref": "#/components/schemas/subscription_request"
          },
          {
            "type": "object",
            "properties": {
              "notification_frequency": {
                "description": "notification frequency in seconds",
                "format": "seconds",
                "title": "notification_frequency",
                "type": "number",
                "x-format-description": "seconds"
              }
            }
          }
        ]
      },
      "device_info": {
        "type": "object",
        "description": "Device info",
        "required": [
          "platform"
        ],
        "properties": {
          "model": {
            "description": "Device model",
            "type": "string"
          },
          "platform": {
            "description": "Device platform",
            "enum": [
              "ios",
              "android"
            ],
            "type": "string"
          },
          "version": {
            "description": "Device platform version",
            "type": "string"
          }
        }
      },
      "vision_spec_presets": {
        "type": "object",
        "properties": {
          "alg": {
            "description": "The algorithm used for video analytics.\n",
            "type": "string",
            "oneOf": [
              {
                "const": "faces",
                "description": "The algorithm for face recognition is used."
              },
              {
                "const": "plates",
                "description": "The algorithm for license plate recognition is used."
              }
            ],
            "example": "faces",
            "x-api-allow": [
              "watcher-admin",
              "watcher-client"
            ]
          }
        }
      },
      "notifications_request": {
        "type": "object",
        "description": "Notification data",
        "required": [
          "title",
          "body"
        ],
        "properties": {
          "title": {
            "description": "Title of notification",
            "type": "string"
          },
          "body": {
            "description": "Body of notification",
            "type": "string"
          }
        }
      },
      "mosaic": {
        "allOf": [
          {
            "$ref": "#/components/schemas/mosaic_base"
          },
          {
            "type": "object",
            "properties": {
              "id": {
                "description": "Mosaic identifier.",
                "type": "integer",
                "readOnly": true,
                "example": 7
              },
              "streams": {
                "items": {
                  "$ref": "#/components/schemas/mosaic_stream"
                },
                "type": "array",
                "description": "The list of streams from which the mosaic is formed.\nThe array is contiguously filled in the order of the streams' arrangement on the mosaic.\nAn empty element corresponds to a cell without a stream.\n",
                "readOnly": true
              }
            }
          }
        ]
      },
      "mosaics_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "mosaics": {
                "items": {
                  "$ref": "#/components/schemas/mosaic"
                },
                "type": "array",
                "description": "List of mosaics"
              }
            }
          }
        ]
      },
      "mosaic_stream": {
        "type": "object",
        "description": "The link to the stream.\nThere may be an empty object. An empty object corresponds to a cell without a stream.\n",
        "properties": {
          "name": {
            "type": "string",
            "description": "Globally unique stream name.",
            "format": "media_name",
            "example": "ag-12345",
            "x-format-description": "media_name"
          },
          "title": {
            "type": "string",
            "description": "Human-readable title of the stream. Provided for SDT MPEG-TS table or\nSDP RTSP title parameter.\n",
            "example": "Hockey channel"
          },
          "playback_token": {
            "type": "string",
            "description": "Temporary token for playback requests (Media Server Streaming API, Central Streaming API).",
            "example": "onetime_token"
          },
          "streaming_endpoint": {
            "description": "HTTP(s) URL that can be used for streaming API of this stream",
            "type": "string",
            "example": "https://ms.example.com"
          },
          "alive": {
            "type": "boolean",
            "description": "A flag indicating if the current stream of the camera is available (true) or not (false).\n"
          }
        }
      },
      "mosaic_base": {
        "type": "object",
        "properties": {
          "title": {
            "description": "Human-readable mosaic name.",
            "type": "string"
          },
          "type": {
            "description": "Use this parameter to specify mosaic display mode and size.",
            "type": "string",
            "oneOf": [
              {
                "const": "1x7",
                "title": "1x7",
                "description": "Size 1x7"
              },
              {
                "const": "2x2",
                "title": "2x2",
                "description": "Size 2x2"
              },
              {
                "const": "3x3",
                "title": "3x3",
                "description": "Size 3x3"
              },
              {
                "const": "4x4",
                "title": "4x4",
                "description": "Size 4x4"
              },
              {
                "const": "5x5",
                "title": "5x5",
                "description": "Size 5x5"
              },
              {
                "const": "6x6",
                "title": "6x6",
                "description": "Size 6x6"
              },
              {
                "const": "7x7",
                "title": "7x7",
                "description": "Size 7x7"
              },
              {
                "const": "8x8",
                "title": "8x8",
                "description": "Size 8x8"
              }
            ],
            "example": "2x2"
          },
          "organization_id": {
            "description": "The identifier of organization that the mosaic is linked to.",
            "type": "integer",
            "example": 9
          }
        }
      },
      "mosaic_save": {
        "allOf": [
          {
            "$ref": "#/components/schemas/mosaic_base"
          },
          {
            "type": "object",
            "properties": {
              "streams": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "Globally unique stream name.",
                      "format": "media_name",
                      "example": "ag-12345",
                      "x-format-description": "media_name"
                    }
                  }
                },
                "description": "The list of streams from which the mosaic is formed.\nThe array is contiguously filled in the order of the streams' arrangement on the mosaic.\nAn empty element corresponds to a cell without a stream.\n"
              }
            }
          }
        ]
      },
      "ptz_command": {
        "type": "object",
        "discriminator": {
          "propertyName": "command",
          "mapping": {
            "move_continuous": "#/components/schemas/ptz_move_continuous"
          }
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/ptz_move_continuous"
          }
        ]
      },
      "audit_log_record": {
        "properties": {
          "created_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The time when the last changes were made.\n",
            "examples": {
              "default": {
                "value": 1637094994000
              }
            },
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "user": {
            "type": "string",
            "description": "Who initiated the last changes.\n",
            "examples": {
              "default": {
                "value": "admin"
              }
            }
          }
        }
      },
      "preset_last_change": {
        "properties": {
          "updated_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The time when the last changes were made.",
            "example": 1672531199000,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "user": {
            "description": "Information about the user who modified.",
            "type": "object",
            "properties": {
              "id": {
                "type": "integer",
                "description": "Identifier of the user.\n",
                "example": 1
              },
              "name": {
                "type": "string",
                "description": "User name (login)\n",
                "example": "admin"
              }
            }
          }
        }
      },
      "stream_user_permission": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "permissions": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/stream_permissions_access"
                  },
                  {
                    "type": "object",
                    "description": "Permissions for the stream"
                  }
                ]
              }
            }
          },
          {
            "type": "object",
            "properties": {
              "user": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/user_base_steam_permissions"
                  },
                  {
                    "type": "object",
                    "description": "A user who has been granted access via stream permissions."
                  }
                ]
              }
            }
          }
        ]
      },
      "stream_users_permissions_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "users_permissions": {
                "items": {
                  "$ref": "#/components/schemas/stream_user_permission"
                },
                "type": "array",
                "description": "List of users"
              }
            }
          }
        ]
      },
      "user_stream_permission": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "permissions": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/stream_permissions_access"
                  },
                  {
                    "type": "object",
                    "description": "Permissions for the stream"
                  }
                ]
              }
            }
          },
          {
            "type": "object",
            "properties": {
              "stream": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/stream_base_stream_permissions"
                  },
                  {
                    "type": "object",
                    "description": "A stream who has been granted access via stream permissions."
                  }
                ]
              }
            }
          }
        ]
      },
      "user_streams_permissions_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "streams_permissions": {
                "items": {
                  "$ref": "#/components/schemas/user_stream_permission"
                },
                "type": "array",
                "description": "List of streams"
              }
            }
          }
        ]
      },
      "stream_permissions_access": {
        "type": "object",
        "properties": {
          "can_view": {
            "type": "boolean",
            "description": "Whether the user can view the stream"
          },
          "can_view_dvr": {
            "type": "boolean",
            "description": "Whether the user can view the stream archive"
          },
          "can_use_ptz": {
            "type": "boolean",
            "description": "Whether the user can control PTZ cameras"
          },
          "dvr_depth_limit": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum archive depth in seconds that user can access"
          }
        }
      },
      "user_base_steam_permissions": {
        "type": "object",
        "description": "A user who has been granted access via stream permissions.",
        "properties": {
          "id": {
            "type": "integer",
            "description": "User identifier",
            "readOnly": true
          }
        }
      },
      "stream_base_stream_permissions": {
        "type": "object",
        "description": "A stream who has been granted access via stream permissions.",
        "properties": {
          "name": {
            "type": "string",
            "description": "Stream name",
            "readOnly": true
          }
        }
      },
      "camera_tag_wb": {
        "type": "object",
        "properties": {}
      },
      "error": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "a unique identifier for this particular occurrence of the problem\n"
          },
          "status": {
            "type": "string",
            "description": "the HTTP status code applicable to this problem, expressed as a string value\n"
          },
          "code": {
            "type": "string",
            "description": "an application-specific error code, expressed as a string value\n"
          },
          "title": {
            "type": "string",
            "description": "a short, human-readable summary of the problem that SHOULD NOT change from\noccurrence to occurrence of the problem, except for purposes of localization\n"
          },
          "source": {
            "description": "an object containing references to the source of the error\n",
            "type": "object",
            "properties": {
              "pointer": {
                "type": "string",
                "description": "a JSON Pointer [RFC6901] to the associated entity in the request document\n[e.g. `\"/data\"` for a primary data object, or `\"/data/attributes/title\"` for a specific attribute].\n"
              },
              "parameter": {
                "type": "string",
                "description": "a string indicating which URI query parameter caused the error."
              }
            }
          },
          "meta": {
            "type": "object",
            "description": "a meta object containing non-standard meta-information about the error.\n",
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "locale": {
        "description": "The locale",
        "type": "string",
        "format": "ISO 639-1",
        "example": "en"
      },
      "map": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/map_base"
          },
          {
            "$ref": "#/components/schemas/map_custom"
          }
        ],
        "discriminator": {
          "propertyName": "provider",
          "mapping": {
            "yandex": "#/components/schemas/map_base",
            "google": "#/components/schemas/map_base",
            "osm": "#/components/schemas/map_base",
            "custom": "#/components/schemas/map_custom"
          }
        }
      },
      "map_base": {
        "type": "object",
        "description": "Properties of the map",
        "required": [
          "provider"
        ],
        "properties": {
          "center": {
            "description": "Coordinates of map center.",
            "allOf": [
              {
                "$ref": "#/components/schemas/map_spec"
              }
            ]
          },
          "api_key": {
            "description": "Map server API Key if required.",
            "type": "string"
          },
          "provider": {
            "type": "string",
            "description": "Provider of the maps."
          }
        }
      },
      "map_custom": {
        "allOf": [
          {
            "$ref": "#/components/schemas/map_base"
          },
          {
            "type": "object",
            "required": [
              "url"
            ],
            "properties": {
              "url": {
                "description": "Custom map server url.",
                "type": "string",
                "format": "url",
                "x-format-description": "url"
              }
            }
          }
        ]
      },
      "media_info": {
        "allOf": [
          {
            "$ref": "#/components/schemas/media_info_specific"
          },
          {
            "$ref": "#/components/schemas/media_info_common"
          }
        ]
      },
      "media_info_specific": {
        "type": "object",
        "properties": {
          "flow_type": {
            "description": "Whether it is a file with a finite start and end time or a live stream.",
            "oneOf": [
              {
                "const": "file"
              },
              {
                "const": "stream"
              },
              {
                "const": "dvr_file"
              },
              {
                "const": "dvr_stream"
              }
            ],
            "type": "string",
            "example": "stream"
          },
          "tracks": {
            "description": "Information about available tracks (video, audio, or text).",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/track_info"
                }
              ]
            },
            "type": "array",
            "default": [],
            "x-api-allow": [
              "smartcam"
            ]
          },
          "duration": {
            "type": "number",
            "format": "ticks",
            "description": "Duration of the media, if applicable.",
            "x-format-description": "ticks"
          }
        }
      },
      "track_info": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/track_info_video"
          },
          {
            "$ref": "#/components/schemas/track_info_audio"
          },
          {
            "$ref": "#/components/schemas/track_info_text"
          },
          {
            "$ref": "#/components/schemas/track_info_metadata"
          },
          {
            "$ref": "#/components/schemas/track_info_application"
          }
        ],
        "discriminator": {
          "propertyName": "content",
          "mapping": {
            "video": "#/components/schemas/track_info_video",
            "audio": "#/components/schemas/track_info_audio",
            "text": "#/components/schemas/track_info_text",
            "metadata": "#/components/schemas/track_info_metadata",
            "application": "#/components/schemas/track_info_application"
          }
        },
        "x-record-definition": "#/components/schemas/track_info_full"
      },
      "track_info_video": {
        "allOf": [
          {
            "$ref": "#/components/schemas/track_info_base"
          },
          {
            "$ref": "#/components/schemas/track_info_base_configurable"
          },
          {
            "type": "object",
            "properties": {
              "codec": {
                "description": "Codec of the track. Different codecs do **not** get the same track.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/frame_codec"
                  }
                ],
                "example": "h264",
                "x-api-allow": [
                  "smartcam",
                  "iris-hal"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/track_info_video_specific"
          },
          {
            "$ref": "#/components/schemas/track_info_video_configurable"
          }
        ]
      },
      "track_info_base": {
        "type": "object",
        "properties": {
          "track_id": {
            "description": "Track identifier assigned by Flussonic.",
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "string"
              }
            ],
            "example": "v1"
          },
          "frame_duration": {
            "description": "For video track, it is the time between the beginning of a frame and the beginning of the next frame.\n\nThis parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.\nHowever, sometimes (when the connection is broken) video breakups are possible.\nAs result, the delta between two consequent frame timestamps will not be equal to the frame duration.\nThis situation is considered as a frame gap and is handled differently across different protocols.\n",
            "type": "number",
            "format": "ticks",
            "x-format-description": "ticks"
          },
          "avg_fps": {
            "description": "Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).\nThe higher FPS is, the smoother the video playback is. \nUsually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).\n",
            "type": "number",
            "x-notice": "calculated fps for statistic"
          },
          "bandwidth": {
            "description": "Bandwidth necessary to transfer this track.\nThis is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead\n",
            "type": "integer",
            "format": "speed",
            "example": 2600,
            "x-format-description": "speed"
          }
        }
      },
      "track_info_base_configurable": {
        "type": "object",
        "required": [
          "content"
        ],
        "properties": {
          "content": {
            "description": "Content of the track (audio, video, or text).",
            "allOf": [
              {
                "$ref": "#/components/schemas/frame_content"
              }
            ],
            "x-api-allow": [
              "smartcam",
              "iris-hal"
            ]
          },
          "title": {
            "description": "Human-readable localized title of the track.",
            "type": "string",
            "x-notice": "Human-readable localized title for HDS/HLS",
            "example": "Video1"
          },
          "bitrate": {
            "description": "Bitrate of the track in kbit/s.\nWhen using sdtv/hdtv/uhdtv transcoder target, for video tracks\nthis field sets the desired transport bandwidth instead of raw video bitrate.\n",
            "type": "integer",
            "format": "speed",
            "example": 2543,
            "x-api-allow": [
              "smartcam",
              "iris-hal"
            ],
            "x-format-description": "speed"
          },
          "pid": {
            "description": "This parameter sets PIDs values for outgoing MPEG-TS streams.\nPID identifies separate data stream inside the multiplexed MPEG-TS stream.\nIt is possible to set PID values for PMT, SDT, video, and audio tracks.\nTracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.\n\nIt is possible to set the base index for the tracks of a certain type using the 0 (zero) index.\nFor example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.\nNumbers can be given in decimal form (by default) or hexadecimal with 16# prefix.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/ts_pid"
              }
            ]
          }
        }
      },
      "frame_content": {
        "type": "string",
        "oneOf": [
          {
            "title": "Audio",
            "const": "audio"
          },
          {
            "title": "Video",
            "const": "video"
          },
          {
            "title": "Text",
            "const": "text"
          },
          {
            "title": "Metadata",
            "const": "metadata"
          },
          {
            "title": "Application",
            "const": "application"
          }
        ]
      },
      "ts_pid": {
        "maximum": 8191,
        "minimum": 0,
        "type": "integer"
      },
      "frame_codec": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/frame_video_codec"
          },
          {
            "$ref": "#/components/schemas/frame_audio_codec"
          },
          {
            "$ref": "#/components/schemas/frame_raw_codec"
          },
          {
            "$ref": "#/components/schemas/frame_text_codec"
          },
          {
            "$ref": "#/components/schemas/frame_app_codec"
          }
        ]
      },
      "frame_video_codec": {
        "type": "string",
        "oneOf": [
          {
            "title": "H.264",
            "const": "h264"
          },
          {
            "title": "HEVC (H.265)",
            "const": "hevc"
          },
          {
            "title": "MP2V",
            "const": "mp2v"
          },
          {
            "title": "VP9",
            "const": "vp9",
            "deprecated": true,
            "x-delete-at": 23.09
          },
          {
            "title": "MJPEG",
            "const": "mjpeg"
          },
          {
            "title": "Screen",
            "const": "screen"
          },
          {
            "title": "JPEG",
            "const": "jpeg"
          },
          {
            "title": "AV1",
            "const": "av1"
          },
          {
            "title": "JPEG 2000",
            "const": "j2k"
          }
        ]
      },
      "frame_audio_codec": {
        "type": "string",
        "oneOf": [
          {
            "title": "AAC",
            "const": "aac",
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ]
          }
        ]
      },
      "frame_raw_codec": {
        "type": "string",
        "oneOf": [
          {
            "title": "YUV",
            "const": "yuv"
          },
          {
            "title": "UYVY422",
            "const": "uyvy422"
          },
          {
            "title": "YUYV422",
            "const": "yuyv422"
          },
          {
            "title": "YUV422p10",
            "const": "yuv422p10"
          },
          {
            "title": "ARGB",
            "const": "argb"
          },
          {
            "title": "RGB48",
            "const": "rgb48"
          },
          {
            "title": "V210",
            "const": "v210"
          },
          {
            "title": "PCM",
            "const": "pcm"
          },
          {
            "title": "R210",
            "const": "r210"
          }
        ]
      },
      "frame_text_codec": {
        "type": "string",
        "oneOf": [
          {
            "title": "TTXT",
            "const": "ttxt"
          },
          {
            "title": "Text",
            "const": "text"
          },
          {
            "title": "WVTT",
            "const": "wvtt"
          },
          {
            "title": "TTML",
            "const": "ttml"
          },
          {
            "title": "Subtitle",
            "const": "subtitle"
          },
          {
            "title": "ID3T",
            "const": "id3t"
          },
          {
            "title": "ONVIF",
            "const": "onvif"
          },
          {
            "title": "TX3G",
            "const": "tx3g"
          }
        ]
      },
      "frame_app_codec": {
        "oneOf": [
          {
            "title": "MPEG-TS",
            "const": "mpegts"
          },
          {
            "title": "Object",
            "const": "object"
          },
          {
            "title": "EIT",
            "const": "eit"
          },
          {
            "title": "SCTE-27",
            "const": "scte27"
          },
          {
            "title": "SCTE-35",
            "const": "scte35"
          },
          {
            "title": "KLV",
            "const": "klv"
          },
          {
            "title": "Empty",
            "const": "empty"
          }
        ],
        "type": "string"
      },
      "track_info_video_specific": {
        "type": "object",
        "properties": {
          "last_gop": {
            "description": "Last GOP size (expressed in number of frames).\nThis parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.\nIf this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.\nThis is not acceptable by most ABR usecases and it will not pass DVB validation protocol.\n",
            "type": "integer",
            "example": 28
          },
          "avg_gop": {
            "type": "integer",
            "description": "Average GOP size (expressed in number of frames) of the last 1000-2000 frames.\nThis parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.\nIf this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.\nThis is not acceptable by most ABR usecases and it will not pass DVB validation protocol.\n",
            "example": 25
          },
          "length_size": {
            "enum": [
              2,
              4
            ],
            "default": 4,
            "type": "integer",
            "x-notice": "H264 private option",
            "description": "The size of the length field for H264 bitstream without start codes."
          },
          "is_progressive": {
            "description": "Indicates if progressive scanning method is used for all frames of the track\n",
            "type": "boolean",
            "default": true
          },
          "closed_captions": {
            "description": "Parameters of closed captions.",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/closed_captions"
                }
              ]
            },
            "type": "array",
            "default": []
          }
        }
      },
      "closed_captions": {
        "type": "object",
        "properties": {
          "language": {
            "description": "Language of closed captions.",
            "type": "string",
            "example": "eng"
          },
          "name": {
            "description": "Under what name the audio track will be displayed on the player.",
            "type": "string",
            "example": "English"
          }
        }
      },
      "track_info_video_configurable": {
        "type": "object",
        "properties": {
          "width": {
            "description": "The picture width in pixels on the display where it will be played by a player.\nIf you need to insert a web-player into a web page, use this value for choosing the player size.\n",
            "type": "integer",
            "format": "pixels",
            "x-api-allow": [
              "smartcam"
            ],
            "x-format-description": "pixels"
          },
          "height": {
            "description": "The picture height in pixels on the display where it will be played by a player.\nIf you need to insert a web-player into a web page, use this value for choosing the player size.\n",
            "type": "integer",
            "format": "pixels",
            "x-api-allow": [
              "smartcam"
            ],
            "x-format-description": "pixels"
          },
          "fps": {
            "description": "Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.\nHigher frame rates capture more images per second, which makes for smoother video.\nThe standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.\nThe standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps\n(a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)\nIf interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,\nbut the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames). \n",
            "type": "number",
            "x-api-allow": [
              "smartcam"
            ]
          },
          "pix_fmt": {
            "allOf": [
              {
                "$ref": "#/components/schemas/frame_video_pix_fmt"
              }
            ],
            "default": "yuv420p",
            "description": "The color model of the video."
          },
          "num_refs_frames": {
            "type": "integer",
            "maximum": 32,
            "minimum": 0,
            "description": "The number of I-frames to be used for encoding."
          },
          "sar_width": {
            "description": "The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.\nSAR is used for creating non-anamorphic video from anamorphic video.\n",
            "default": 1,
            "type": "integer",
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://flussonic.com/doc/transcoder-internals/#transcoder-options_sar"
            }
          },
          "sar_height": {
            "description": "The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.\nSAR is used for creating non-anamorphic video from anamorphic video.\n",
            "default": 1,
            "type": "integer",
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://flussonic.com/doc/transcoder-internals/#transcoder-options_sar"
            }
          },
          "pixel_width": {
            "description": "The picture width in pixels of the original video before transcoding.",
            "type": "integer",
            "format": "pixels",
            "x-format-description": "pixels"
          },
          "pixel_height": {
            "description": "The picture width in pixels of the original video before transcoding.",
            "type": "integer",
            "format": "pixels",
            "x-format-description": "pixels"
          },
          "level": {
            "type": "string",
            "description": "A set of constraints that indicate a degree of required decoder performance.\nThis parameter is used for compatibility with old devices.\n",
            "x-api-allow": [
              "smartcam"
            ]
          },
          "profile": {
            "description": "A specific codec-dependent profile of the output video.\nThe profile allows to assume if the track can be played on a particular device.\n",
            "type": "string",
            "x-api-allow": [
              "smartcam"
            ]
          },
          "bframes": {
            "description": "Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.\nB-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.\nThis value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.\n",
            "type": "integer",
            "x-notice": "calculated number of bframes for statistic",
            "example": 3
          },
          "gop_size": {
            "description": "The number of frames in a group of pictures (GOP). \nThe encoder will create all GOPs of an exactly identical size - as specified in this option.\nA bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)\n",
            "type": "integer",
            "x-api-allow": [
              "smartcam"
            ]
          }
        }
      },
      "frame_video_pix_fmt": {
        "type": "string",
        "oneOf": [
          {
            "title": "YUV420P",
            "const": "yuv420p"
          },
          {
            "title": "YUVJ420P",
            "const": "yuvj420p"
          },
          {
            "title": "YUV422P",
            "const": "yuv422p"
          },
          {
            "title": "YUV444P",
            "const": "yuv444p"
          },
          {
            "title": "YUV420P10",
            "const": "yuv420p10"
          },
          {
            "title": "YUV422P10",
            "const": "yuv422p10"
          },
          {
            "title": "YUV444P10",
            "const": "yuv444p10"
          },
          {
            "title": "YUV420P12",
            "const": "yuv420p12"
          },
          {
            "title": "YUV422P12",
            "const": "yuv422p12"
          },
          {
            "title": "YUV444P12",
            "const": "yuv444p12"
          },
          {
            "title": "Gray8",
            "const": "gray8"
          },
          {
            "title": "Gray10",
            "const": "gray10"
          },
          {
            "title": "Gray12",
            "const": "gray12"
          },
          {
            "title": "NV12",
            "const": "nv12"
          },
          {
            "title": "P016",
            "const": "p016"
          },
          {
            "title": "V210",
            "const": "v210"
          },
          {
            "title": "UYVY422",
            "const": "uyvy422"
          },
          {
            "title": "YUYV422",
            "const": "yuyv422"
          },
          {
            "title": "RGB48",
            "const": "rgb48"
          },
          {
            "title": "ARGB",
            "const": "argb"
          },
          {
            "title": "x2rgb10be",
            "const": "x2rgb10be"
          }
        ]
      },
      "track_info_audio": {
        "allOf": [
          {
            "$ref": "#/components/schemas/track_info_base"
          },
          {
            "$ref": "#/components/schemas/track_info_base_configurable"
          },
          {
            "type": "object",
            "properties": {
              "codec": {
                "description": "Codec of the track. Different codecs do **not** get the same track.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/frame_codec"
                  }
                ],
                "example": "h264",
                "x-api-allow": [
                  "smartcam",
                  "iris-hal"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/track_info_audio_specific"
          }
        ]
      },
      "track_info_audio_specific": {
        "type": "object",
        "properties": {
          "channels": {
            "description": "The number of audio channels.",
            "type": "integer",
            "example": 2,
            "x-api-allow": [
              "smartcam"
            ]
          },
          "sample_rate": {
            "description": "Sample rate, in hertz -\nthe number of samples per second taken from a continuous signal to make a discrete or digital signal.\n",
            "type": "integer",
            "example": 8000,
            "x-api-allow": [
              "smartcam"
            ]
          },
          "language": {
            "description": "Language value of the track, if applicable.",
            "type": "string",
            "example": "eng"
          }
        }
      },
      "track_info_text": {
        "allOf": [
          {
            "$ref": "#/components/schemas/track_info_base"
          },
          {
            "$ref": "#/components/schemas/track_info_base_configurable"
          },
          {
            "type": "object",
            "properties": {
              "codec": {
                "description": "Codec of the track. Different codecs do **not** get the same track.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/frame_codec"
                  }
                ],
                "example": "h264",
                "x-api-allow": [
                  "smartcam",
                  "iris-hal"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/track_info_text_specific"
          }
        ]
      },
      "track_info_text_specific": {
        "type": "object",
        "properties": {
          "language": {
            "description": "Language value of the track, if applicable.",
            "type": "string",
            "example": "eng"
          }
        }
      },
      "track_info_metadata": {
        "allOf": [
          {
            "$ref": "#/components/schemas/track_info_base"
          },
          {
            "$ref": "#/components/schemas/track_info_base_configurable"
          },
          {
            "type": "object",
            "properties": {
              "codec": {
                "description": "Codec of the track. Different codecs do **not** get the same track.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/frame_codec"
                  }
                ],
                "example": "h264",
                "x-api-allow": [
                  "smartcam",
                  "iris-hal"
                ]
              }
            }
          }
        ]
      },
      "track_info_application": {
        "allOf": [
          {
            "$ref": "#/components/schemas/track_info_base"
          },
          {
            "$ref": "#/components/schemas/track_info_base_configurable"
          },
          {
            "type": "object",
            "properties": {
              "codec": {
                "description": "Codec of the track. Different codecs do **not** get the same track.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/frame_codec"
                  }
                ],
                "example": "h264",
                "x-api-allow": [
                  "smartcam",
                  "iris-hal"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/track_info_application_specific"
          }
        ]
      },
      "track_info_application_specific": {
        "type": "object",
        "properties": {
          "language": {
            "description": "Language value of the track, if applicable.",
            "type": "string",
            "example": "eng"
          }
        }
      },
      "media_info_common": {
        "type": "object",
        "properties": {
          "provider": {
            "description": "The media provider of this content.",
            "type": "string",
            "example": "Netflix"
          },
          "title": {
            "description": "Human-readable title of the media.",
            "type": "string",
            "example": "Bunny"
          },
          "stream_id": {
            "type": "integer",
            "example": 253,
            "description": "The identifier of the transport stream for MPEG TS streams."
          },
          "program_id": {
            "type": "integer",
            "example": 110,
            "description": "The program ID for MPEG TS streams."
          }
        }
      },
      "stream_status": {
        "type": "string",
        "oneOf": [
          {
            "title": "Running",
            "const": "running",
            "description": "Input is OK, stream is ready to be served to your audience."
          },
          {
            "title": "Waiting",
            "const": "waiting",
            "description": "Flussonic awaits for input (publish) or it's an 'on demand' stream waiting for client."
          },
          {
            "title": "Error",
            "const": "error",
            "description": "Something is wrong and Flussonic is not able to serve the stream to your audience."
          }
        ]
      },
      "input_stats": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "ip": {
                "type": "string",
                "description": "IP address of the connected peer.",
                "example": "172.16.25.73"
              },
              "proto": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/protocol"
                  }
                ],
                "description": "Protocol used for the data transmission in the session.",
                "example": "dash"
              },
              "opened_at": {
                "type": "number",
                "format": "utc_ms",
                "description": "The time when this session was created.",
                "example": 1637094994000,
                "x-format-description": "Unix timestamp in milliseconds",
                "minimum": 1000000000000,
                "maximum": 10000000000000
              },
              "media_info": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/media_info"
                  }
                ],
                "description": "Technical description of the input content.\n"
              },
              "ts_delay": {
                "type": "number",
                "format": "ticks",
                "example": 1284,
                "description": "The time period during which no frames were received from the stream's input.\n",
                "x-format-description": "ticks"
              },
              "ts_delay_per_tracks": {
                "type": "array",
                "items": {
                  "type": "number",
                  "format": "ticks",
                  "x-format-description": "ticks"
                },
                "example": [
                  1284
                ],
                "description": "The time period during which no frames were received per each track according to `media_info`\n"
              },
              "url": {
                "type": "string",
                "format": "url",
                "description": "Final URL after redirects.\n\nDeprecated because was never actually used.\n",
                "example": "udp://239.0.0.1:1234",
                "deprecated": true,
                "x-delete-at": 25.03,
                "x-format-description": "url"
              },
              "user_agent": {
                "type": "string",
                "description": "Client's user agent for selected protocol.",
                "example": "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML. like Gecko) Chrome/90.0.4430.72 Safari/537.36"
              },
              "active": {
                "description": "Whether this input is selected as active for the stream.",
                "type": "boolean",
                "example": true
              },
              "divergent_inputs": {
                "description": "Indicates that the stream sources have different track sets, which may cause switching problems. The list of tracks to be compared is obtained only when the sources are checked or started, until then the stream is considered normal.",
                "type": "boolean"
              },
              "dvr_info": {
                "description": "Information about DVR that this input has\n",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/dvr_info"
                  }
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/input_counters"
          }
        ]
      },
      "protocol": {
        "type": "string",
        "oneOf": [
          {
            "title": "copy",
            "const": "copy"
          },
          {
            "title": "fake",
            "const": "fake"
          },
          {
            "title": "RTP",
            "const": "rtp"
          },
          {
            "title": "RTMP",
            "const": "rtmp"
          },
          {
            "title": "RTMPS",
            "const": "rtmps"
          },
          {
            "title": "RTMPE",
            "const": "rtmpe"
          },
          {
            "title": "RTSP",
            "const": "rtsp"
          },
          {
            "title": "RTSP-UDP",
            "const": "rtsp-udp"
          },
          {
            "title": "RTSP2",
            "const": "rtsp2"
          },
          {
            "title": "RTSPS",
            "const": "rtsps"
          },
          {
            "title": "EST",
            "const": "est"
          },
          {
            "title": "SRT",
            "const": "srt"
          },
          {
            "title": "MSE-LD",
            "const": "mseld"
          },
          {
            "title": "SHOUTcast",
            "const": "shoutcast"
          },
          {
            "title": "SHOUTcasts",
            "const": "shoutcasts"
          },
          {
            "title": "WebRTC",
            "const": "webrtc"
          },
          {
            "title": "HLS",
            "const": "hls"
          },
          {
            "title": "HLSS",
            "const": "hlss"
          },
          {
            "title": "HLS2",
            "const": "hls2"
          },
          {
            "title": "HLSS2",
            "const": "hlss2"
          },
          {
            "title": "LL-HLS",
            "const": "llhls"
          },
          {
            "title": "CMAF",
            "const": "cmaf"
          },
          {
            "title": "DASH",
            "const": "dash"
          },
          {
            "title": "MSS",
            "const": "mss"
          },
          {
            "title": "M4S",
            "const": "m4s"
          },
          {
            "title": "M4SS",
            "const": "m4ss"
          },
          {
            "title": "M4F",
            "const": "m4f"
          },
          {
            "title": "M4FS",
            "const": "m4fs"
          },
          {
            "title": "HTTP MPEG-TS",
            "const": "tshttp"
          },
          {
            "title": "HTTPS MPEG-TS",
            "const": "tshttps"
          },
          {
            "title": "TCP MPEG-TS",
            "const": "tstcp"
          },
          {
            "title": "SSL MPEG-TS",
            "const": "tsssl"
          },
          {
            "title": "FLV",
            "const": "flv"
          },
          {
            "title": "annexB",
            "const": "annexb"
          },
          {
            "title": "UDP",
            "const": "udp"
          },
          {
            "title": "UDP1",
            "const": "udp1"
          },
          {
            "title": "UDP2",
            "const": "udp2"
          },
          {
            "title": "UDP3",
            "const": "udp3"
          },
          {
            "title": "UDP MPTS",
            "const": "mpts-udp"
          },
          {
            "title": "HTTP MPTS",
            "const": "mpts-http"
          },
          {
            "title": "HTTPS MPTS",
            "const": "mpts-https"
          },
          {
            "title": "DVB MPTS",
            "const": "mpts-dvb"
          },
          {
            "title": "DVB",
            "const": "dvb"
          },
          {
            "title": "Decklink",
            "const": "decklink"
          },
          {
            "title": "DekTec",
            "const": "dektec"
          },
          {
            "title": "DekTec ASI",
            "const": "dektec-asi"
          },
          {
            "title": "v4l",
            "const": "v4l"
          },
          {
            "title": "v4l2",
            "const": "v4l2"
          },
          {
            "title": "Playlist",
            "const": "playlist"
          },
          {
            "title": "Mixer",
            "const": "mixer"
          },
          {
            "title": "Mosaic",
            "const": "mosaic"
          },
          {
            "title": "Mosaic2",
            "const": "mosaic2"
          },
          {
            "title": "Timeshift",
            "const": "timeshift"
          },
          {
            "title": "File",
            "const": "file"
          },
          {
            "title": "Download",
            "const": "download"
          },
          {
            "title": "MBR",
            "const": "mbr"
          },
          {
            "title": "MP4",
            "const": "mp4"
          },
          {
            "title": "Logo",
            "const": "logo"
          },
          {
            "title": "JPEG",
            "const": "jpeg"
          },
          {
            "title": "MJPEG",
            "const": "mjpeg"
          },
          {
            "title": "H.323",
            "const": "h323"
          },
          {
            "title": "Ad injector",
            "const": "ad_injector"
          },
          {
            "title": "ffmpeg",
            "const": "ffmpeg"
          },
          {
            "title": "Transponder",
            "const": "transponder"
          },
          {
            "title": "API",
            "const": "api"
          },
          {
            "title": "JSON manifest",
            "const": "json_manifest"
          },
          {
            "title": "Player",
            "const": "player"
          },
          {
            "title": "NDI",
            "const": "ndi"
          },
          {
            "title": "FRIP",
            "const": "frip"
          },
          {
            "title": "ST2110",
            "const": "st2110"
          },
          {
            "title": "Backup",
            "const": "backup"
          }
        ]
      },
      "dvr_info": {
        "type": "object",
        "properties": {
          "from": {
            "type": "integer",
            "format": "utc",
            "description": "The UTC timestamp of the first recording in this archive.",
            "example": 1641045644,
            "x-format-description": "Unix timestamp in seconds",
            "minimum": 1000000000,
            "maximum": 10000000000
          },
          "depth": {
            "type": "integer",
            "format": "seconds",
            "description": "The time interval between the start of the *first* recording segment and the end of the *last* one.",
            "example": 259200,
            "x-format-description": "seconds"
          },
          "ranges": {
            "deprecated": true,
            "x-delete-at": 24.09,
            "description": "The list of DVR ranges. The param is replaced with `ranges_list` method.",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/dvr_range"
                }
              ]
            },
            "type": "array"
          },
          "bytes": {
            "description": "The size of the recorded archive.",
            "type": "integer",
            "format": "bytes",
            "example": 129600000000,
            "x-format-description": "bytes"
          },
          "disk_size": {
            "description": "The size of the recorded archive. Please, use bytes instead.",
            "type": "integer",
            "format": "bytes",
            "example": 1099511627776,
            "deprecated": true,
            "x-delete-at": 25.07,
            "x-format-description": "bytes"
          },
          "duration": {
            "type": "integer",
            "format": "seconds",
            "description": "A total duration of the recorded segments, excluding recording gaps.\nIt can be smaller than depth if you have gaps.\n",
            "example": 172800,
            "x-format-description": "seconds"
          }
        },
        "required": [
          "from",
          "depth",
          "ranges"
        ]
      },
      "dvr_range": {
        "type": "object",
        "properties": {
          "from": {
            "description": "The beginning of the recorded DVR range. Use opened_at instead.\nMention that opened_at has milliseconds\n",
            "type": "integer",
            "format": "utc",
            "example": 1525186456,
            "deprecated": true,
            "x-delete-at": 24.11,
            "x-format-description": "Unix timestamp in seconds",
            "minimum": 1000000000,
            "maximum": 10000000000
          },
          "duration": {
            "description": "The duration of the recorded DVR range.\nUse closed_at instead of this field. \n",
            "type": "integer",
            "format": "seconds",
            "example": 28800,
            "deprecated": true,
            "x-delete-at": 24.11,
            "x-format-description": "seconds"
          },
          "opened_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The time when this range was started. Naming is standard for whole flussonic ecosystem.\n\nIs a replacement for field `from`\n",
            "examples": {
              "default": {
                "value": 1637094994000
              }
            },
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "closed_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The the of the last recorded data.\n\nPlease notice that closed_at could be changed. There are two reasons.\n- Cleaner process reduced data. Read [more](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_get/response%7Cdvr%7Cepisodes_url).\n- Recording is still working. Near real-time value means that DVR is active at the moment.\n\nThis is a replacement for `duration` field\n",
            "examples": {
              "default": {
                "value": 1637094994000
              }
            },
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          }
        }
      },
      "input_counters": {
        "type": "object",
        "description": "Here are grouped different counters for sessions: generic and errors\n",
        "properties": {
          "bytes": {
            "type": "integer",
            "format": "bytes",
            "default": 0,
            "description": "Number of bytes received by this stream from live sources.\nIt will be counted before transcoding and will sum all inputs working together.\n",
            "openmetrics_metric": "stream_input_bytes",
            "x-format-description": "bytes"
          },
          "bytes_dvr": {
            "type": "integer",
            "format": "bytes",
            "default": 0,
            "description": "Number of bytes received by this stream when downloading from remote DVR.\n",
            "x-format-description": "bytes"
          },
          "frames": {
            "type": "integer",
            "default": 0,
            "description": "Number of frames passed to this stream from the inputs.\n"
          },
          "retries": {
            "type": "integer",
            "description": "How many times has this stream retried to connect to source"
          },
          "input_switches": {
            "type": "integer",
            "description": "Aggregated: how many times this stream has switched between different inputs.\nIndividual input: number of times switched to this input.\n"
          },
          "media_info_changes": {
            "type": "integer",
            "description": "Indicates, how often does media_info changes\n"
          },
          "valid_secondary_inputs": {
            "description": "Number of secondary inputs that have no problems.",
            "type": "integer",
            "example": 2
          },
          "invalid_secondary_inputs": {
            "description": "Number of secondary inputs that have some problems.",
            "type": "integer",
            "example": 0
          },
          "num_sec_on_primary_input": {
            "description": "How many seconds has this stream played from primary input.",
            "type": "integer",
            "format": "seconds",
            "x-format-description": "seconds"
          },
          "num_sec_on_secondary_input": {
            "description": "How many seconds has this stream played from secondary inputs.",
            "type": "integer",
            "format": "seconds",
            "x-format-description": "seconds"
          },
          "num_sec_no_data": {
            "description": "How many seconds has this stream had no frames.",
            "type": "integer",
            "format": "seconds",
            "x-format-description": "seconds"
          },
          "resync_count_normal": {
            "type": "integer",
            "description": "Stream timestamps are synchronized with real time. This counter tells, how many times\nit was syncronized after source reconnect.\n"
          },
          "resync_count_jump": {
            "type": "integer",
            "description": "Source may change timestamps without any signalling. This counter indicates how bad is the source\n"
          },
          "resync_count_drift": {
            "type": "integer",
            "description": "Source may send frames timestamps faster or slower than realtime.\nLive stream will catch it and resync. This counter indicates how many times did it happened.\n"
          },
          "reorder_count": {
            "type": "integer",
            "description": "Source may send frames not in the order they should be played. It will be catched and reordered.\nThis counter indicates how many times did it happened.\n"
          },
          "ad_splices_ingested": {
            "type": "integer",
            "description": "How many Ad markers passed to this stream from the inputs.\n"
          },
          "ad_splices_inserted": {
            "type": "integer",
            "description": "How many Ad markers inserted to this stream by user.\n"
          },
          "srt": {
            "$ref": "#/components/schemas/input_srt_counters"
          },
          "motion_detector": {
            "$ref": "#/components/schemas/input_motion_detector_counters"
          },
          "errors": {
            "type": "integer",
            "description": "Sum of all other specific errors. Can be used for triggering alert on any error\n",
            "example": 0
          },
          "error_rate": {
            "type": "integer",
            "description": "Sum of all other specific errors in the last minute\n",
            "example": 0
          },
          "errors_lost_packets": {
            "type": "integer",
            "description": "RTP, MPEG-TS or other protocols have enough information to tell how many packets were lost\n"
          },
          "errors_decoder_reset": {
            "type": "integer",
            "description": "Decoder reset count due to abnormal DTS change. Can happen in MPEG-TS, RTP.\n"
          },
          "errors_broken_payload": {
            "type": "integer",
            "description": "Demultiplexing was done right, but content is broken.\n"
          },
          "errors_dropped_frames": {
            "type": "integer",
            "description": "Dropped frames count due timestamp adjustment.\n"
          },
          "errors_desync": {
            "type": "integer",
            "description": "This can be used as a `TS_sync_loss` - how many times MPEG-TS sync was lost.\n\nAlso this counter refers to RTSP desync, when camera starts dropping TCP data and\nwe have to find packet boundaries.\n\nHere we write count of such resynchronizations.\n"
          },
          "errors_ts_pat": {
            "type": "integer",
            "description": "how many times PAT was missing during 0,5 seconds or pid 0 misses PAT\n\n`PAT_error`\n"
          },
          "pids": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/input_pid_counters"
            },
            "description": "Per pid statistics calculated for MPEG-TS input\n"
          },
          "rtp_channels": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/input_rtp_counters"
            },
            "description": "Per channel statistics calculated for RTP input\n"
          },
          "errors_ts_service_lost": {
            "type": "integer",
            "description": "How many times have received PAT that was missing required service (program)\n"
          },
          "errors_ts_stuck_restarts": {
            "type": "integer",
            "description": "Number of connection restarts to fix ts_stuck issue. Can happen in RTSP.\n"
          },
          "errors_404": {
            "type": "integer",
            "description": "How many times we've got 404 (enoent).\n"
          },
          "errors_403": {
            "type": "integer",
            "description": "How many times we've got 403 (eaccess).\n"
          },
          "errors_500": {
            "type": "integer",
            "description": "How many times we've got 500 (backend error).\n"
          },
          "errors_crashed": {
            "type": "integer",
            "description": "How many times input was restarted due to internal crash.\n\nThis may happen due to unhandled input.\n"
          },
          "sdi": {
            "$ref": "#/components/schemas/input_sdi_counters"
          },
          "agent": {
            "$ref": "#/components/schemas/input_agent_counters"
          }
        }
      },
      "input_srt_counters": {
        "type": "object",
        "description": "SRT specific counters\n",
        "properties": {
          "rtt": {
            "type": "integer",
            "description": "Round-trip time\n"
          },
          "latency": {
            "type": "integer",
            "description": "Receiver buffering delay"
          },
          "packets": {
            "type": "integer",
            "description": "Total incoming SRT packets counter\n"
          },
          "retransmitted_packets": {
            "type": "integer",
            "description": "How many packets were retransmitted\n"
          },
          "error_lost_packets": {
            "type": "integer",
            "description": "How many SRT packets were lost\n"
          },
          "error_dropped_packets": {
            "type": "integer",
            "description": "How many SRT packets were dropped by various reasons\n"
          }
        }
      },
      "input_motion_detector_counters": {
        "type": "object",
        "description": "Specific counters to get insights on current state of getting events from cameras.\nDesigned to be used by analyzers, monitoring and alerting tools\n",
        "properties": {
          "motion_detected_count": {
            "type": "integer",
            "description": "Number of detected motions.\n"
          },
          "episodes_count": {
            "type": "integer",
            "description": "Number of collected episodes.\n"
          },
          "errors_not_authorized_count": {
            "type": "integer",
            "description": "Number of not authorized requests\n"
          },
          "errors_url_unreachable_count": {
            "type": "integer",
            "description": "Number of failed requests because of bad url or network issues.\n"
          },
          "errors_broken_payload": {
            "type": "integer",
            "description": "Number of responses with broken content.\n"
          },
          "errors_no_agent_connected": {
            "type": "integer",
            "description": "Number of failed request attempts because of no agent connected.\n"
          },
          "errors_no_service_count": {
            "type": "integer",
            "description": "Number of attempts to request disabled or unsupported ONVIF service  \n"
          },
          "errors_incorrect_time_values_count": {
            "type": "integer",
            "description": "`ONVIF Event Handling Test Specification` says that valid values for `CurrentTime` and `TerminationTime` are \n`TerminationTime >= CurrentTime + InitialTerminationTime`.\n\nHow many responses did not met the condition.\n"
          }
        }
      },
      "input_pid_counters": {
        "type": "object",
        "required": [
          "pid"
        ],
        "properties": {
          "pid": {
            "description": "Related MPEG-TS pid with following problems\n",
            "type": "integer"
          },
          "pnr": {
            "description": "What program does have this pid\n",
            "type": "integer"
          },
          "packets": {
            "description": "How many MPEG-TS packets with 188 bytes on this pid received\n",
            "type": "integer"
          },
          "frames": {
            "description": "Frame count on this pid\n",
            "type": "integer"
          },
          "empty_packets": {
            "description": "Packets without payload and adaptation field\n",
            "type": "integer"
          },
          "errors_adaptation_broken": {
            "description": "Packets with adaptation field larger than packet size\n",
            "type": "integer"
          },
          "errors_ts_scrambled": {
            "type": "integer",
            "description": "Amount of scrambled TS packets\n"
          },
          "errors_ts_pmt": {
            "type": "integer",
            "description": "how many times PMT was not received after 0,5 seconds\n\n`PMT_error`\n"
          },
          "errors_ts_cc": {
            "type": "integer",
            "description": "how many MPEG-TS packets were received with non-contigious contiuity counters.\n\n`Continuity_count_error`\n",
            "example": 0
          },
          "errors_ts_tei": {
            "type": "integer",
            "description": "How many MPEG-TS packets with Transport Error Indicator were received\n\n`Transport_error`, 2.1\n"
          },
          "errors_ts_psi_checksum": {
            "type": "integer",
            "description": "How many times have received PSI entry with broken checksum\n\n`CRC_error`\n"
          },
          "errors_pid_lost": {
            "type": "integer",
            "description": "How many times pid has been lost\n"
          },
          "broken_pes_count": {
            "type": "integer",
            "description": "How many PES packets were started not from startcode\n"
          },
          "broken_pes_sum": {
            "type": "integer",
            "description": "How many bytes were discarded due to lack of PES startcode\n"
          },
          "time_corrections": {
            "type": "integer",
            "description": "Jumps of timestamps inside a MPEG-TS stream\n"
          },
          "repeated_frames": {
            "type": "integer",
            "description": "In case of CC error last frame can be repeated. This is a count of repeated frames\n"
          },
          "corrected_backward_pts": {
            "type": "integer",
            "description": "How many times PTS was less than PCR or previous PTS\n"
          },
          "pcr_resync": {
            "type": "integer",
            "description": "If PTS is drifting away from PCR, it can be resynchronized with PCR. This is a resync count\n"
          },
          "discarded_buffer_count": {
            "type": "integer",
            "description": "How many times was discarded too big ES buffer without making a frame of it\n"
          },
          "discarded_buffer_sum": {
            "type": "integer",
            "description": "How many bytes were lost due to discarding ES buffer\n"
          },
          "fillers_count": {
            "type": "integer",
            "description": "How many H264(5) NAL fillers were seen in the input\n"
          },
          "fillers_sum": {
            "type": "integer",
            "description": "How many bytes were seen in NAL fillers\n"
          },
          "padding_pes_count": {
            "type": "integer",
            "description": "How many PES packets were on the Padding streamId\n"
          },
          "padding_pes_sum": {
            "type": "integer",
            "description": "How many bytes were in PES packets on the Padding streamId\n"
          },
          "crashed": {
            "type": "integer",
            "description": "Unhandled crashes inside mpegts decoding process due\n"
          },
          "dts_goes_backwards": {
            "type": "integer",
            "description": "Time on this PID jumped back from reference PTS and it was not a roll over zero\n"
          },
          "dts_jump_forward": {
            "type": "integer",
            "description": "Time on this PID jumped forward too far away from reference PTS\n"
          },
          "too_large_dts_jump": {
            "type": "integer",
            "description": "Jump of the PTS was so big from previous, that had to flush all frames and restart parsing\n"
          }
        }
      },
      "input_rtp_counters": {
        "allOf": [
          {
            "$ref": "#/components/schemas/rtp_counters_base"
          },
          {
            "$ref": "#/components/schemas/h26x_decoder_counters"
          }
        ]
      },
      "rtp_counters_base": {
        "type": "object",
        "required": [
          "channel_id"
        ],
        "properties": {
          "channel_id": {
            "description": "RTP channel number\n",
            "type": "integer",
            "example": 0
          },
          "content": {
            "description": "Content of the track transmitted in the channel\n",
            "type": "string",
            "example": "video"
          },
          "rtp_packets": {
            "type": "integer",
            "description": "How many RTP packets received for this channel\n"
          },
          "rtcp_packets": {
            "type": "integer",
            "description": "How many RTCP packets received for this channel\n"
          },
          "bytes": {
            "type": "integer",
            "description": "How many bytes received for this channel\n"
          },
          "frames": {
            "type": "integer",
            "description": "How many frames received for this channel\n"
          },
          "pt_reject_count": {
            "type": "integer",
            "description": "Number of rtp packets rejected due to wrong payload type\n"
          },
          "pt_reject_sum": {
            "type": "integer",
            "description": "Total size of rejected packets due to wrong payload type (pt_reject_count) rtp packets\n"
          },
          "ts_goes_backwards": {
            "type": "integer",
            "description": "Time on this channel is jumped back from reference wallclock.\n"
          },
          "ts_jump_forward": {
            "type": "integer",
            "description": "Time on this channel is jumped forward from reference wallclock.\n"
          },
          "ts_stuck": {
            "type": "integer",
            "description": "https://datatracker.ietf.org/doc/html/rfc6184#section-4.1\n\naccess unit: A set of NAL units always containing a primary coded picture.  In addition to the primary coded\npicture, an access unit may also contain one or more redundant coded pictures or other NAL units not containing\nslices or slice data partitions of a coded picture.  The decoding of an access unit always results in a\ndecoded picture.\n\nThere is `marker bit` in RTP packet which is set for the very last packet of the access unit indicated by the RTP timestamp.\n\nIt is protocol violation if received RTP packet has the same timestamp as previous marker bit packet.\n\nThis counter is a number of RTP packets which `RTP timestamp` is equal to previous RTP marker bit packet.\n"
          },
          "errors_dts_stuck": {
            "type": "integer",
            "description": "Number of frames which dts is same as previous frame dts.\n"
          },
          "sr_ts_stuck": {
            "type": "integer",
            "description": "Number of rtcp SR packets which `RTP timestamp` is equal to the previous rtcp SR packet `RTP timestamp`. \n"
          },
          "sender_clock_deviation": {
            "type": "integer",
            "description": "Sender wallclock deviation from server time in ms. Positive value means that sender time is ahead of server time.\n"
          },
          "marker_packets_count": {
            "type": "integer",
            "description": "Number of RTP packets which marker bit is set to one.\n"
          },
          "no_marker_mode_flag": {
            "type": "boolean",
            "description": "If no marker bit packet is received after 400 RTP packets then decoder switches to `no_marker_mode` and\nmakes frame on each timecode change. \n\nThis flag shows if decoder works in `no_marker_mode`.\n"
          },
          "errors_broken_payload": {
            "type": "integer",
            "description": "Demultiplexing was done right, but content is broken.\n"
          },
          "errors_lost_packets": {
            "type": "integer",
            "description": "RTP have enough information to tell how many packets were lost\n"
          },
          "nack_count": {
            "type": "integer",
            "description": "How many NACK messages are sent for this channel\n"
          }
        }
      },
      "h26x_decoder_counters": {
        "type": "object",
        "description": "Here are counters for h264/h265 decoder.\n",
        "properties": {
          "nal_count": {
            "type": "integer",
            "description": "How many NAL units handled by this decoder.\n"
          },
          "discarded_broken_nal_count": {
            "type": "integer",
            "description": "Number of NAL units, which `forbidden_zero_bit` is set to one.\n"
          },
          "discarded_not_allowed_nal_count": {
            "type": "integer",
            "description": "Number of NAL units, which type is not allowed in `non-interleaved packetization mode`.\n"
          },
          "nal_fu_count": {
            "type": "integer",
            "description": "`Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.\n`H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.\n\nThis counter shows how many `Fragmentation Units` handled by this decoder. \n"
          },
          "nal_stap_a_count": {
            "type": "integer",
            "description": "How many NAL `STAP_A` units handled by this decoder.\n"
          },
          "nal_aggregation_count": {
            "type": "integer",
            "description": "How many NAL `AGGREGATION` units handled by this decoder.\n"
          },
          "fu_pattern_is_broken_count": {
            "type": "integer",
            "description": "`Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.\n`H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.\n\n`Fragmentation Units` pattern must have a `Start FU`, `End FU` and could have `FUs` between these ones. \n\nThis counter indicates how many times pattern was broken.\n"
          },
          "fu_has_both_start_end_bits_count": {
            "type": "integer",
            "description": "`Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.\n`H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.\n\nThis counter shows number of `Fragmentation Units` which `Start bit` and `End bit` are set to one in the same `FU` header\n"
          },
          "incomplete_nal_count": {
            "type": "integer",
            "description": "NAL deframentation could be interrupted by unexpected NAL or broken/incomplete packet.\nIf NAL deframentation is interrupted then incomplete fragment of NAL is not discarded and used in decoding process.\n\nThis counter indicates how many incomplete NALs were used.  \n"
          },
          "discarded_fu_count": {
            "type": "integer",
            "description": "`Fragmentation Unit` used to fragment a single NAL unit over multiple RTP packets.\n`H.264` uses `FU-A` NAL. `H.265` has its own fragmentation unit.\n\nThis counter shows number of discarded `Fragmentation Units`\n"
          },
          "fu_end_then_middle_workaround_count": {
            "type": "integer",
            "description": "There is workaround to not interrupt `FU` sequence if `end-FU` followed by `middle-FU`. \nThis counter shows how many time the workaround was applied.\n"
          },
          "nal_sei_count": {
            "type": "integer",
            "description": "How many NAL `SEI` units handled by this decoder.\n"
          },
          "invalid_sei_type_count": {
            "type": "integer",
            "description": "Number of `SEI` NAL units with invalid type\n"
          },
          "invalid_sei_size_count": {
            "type": "integer",
            "description": "Number of `SEI` NAL units with invalid size\n"
          },
          "invalid_sei_payload_count": {
            "type": "integer",
            "description": "Number of `SEI` NAL units with bad payload\n"
          },
          "discarded_sei_count": {
            "type": "integer",
            "description": "Number of discarded `SEI` NAL units\n"
          },
          "nal_idr_count": {
            "type": "integer",
            "description": "How many NAL `IDR` units handled by this decoder.\n"
          },
          "nal_single_count": {
            "type": "integer",
            "description": "How many NAL `SINGLE` units handled by this decoder. \n"
          },
          "nal_sps_count": {
            "type": "integer",
            "description": "How many NAL `SPS` units handled by this decoder.\n"
          },
          "nal_pps_count": {
            "type": "integer",
            "description": "How many NAL `PPS` units handled by this decoder.\n"
          },
          "nal_aud_count": {
            "type": "integer",
            "description": "How many NAL `AUD` units handled by this decoder.\n"
          },
          "nal_filler_count": {
            "type": "integer",
            "description": "How many NAL `FILLER` units handled by this decoder.\n"
          },
          "nal_slice_count": {
            "type": "integer",
            "description": "How many NAL `SLICE` units handled by this decoder.\n"
          },
          "nal_vps_count": {
            "type": "integer",
            "description": "How many NAL `VPS` units handled by this decoder.\n"
          },
          "nal_other_count": {
            "type": "integer",
            "description": "How many other NAL units handled by this decoder.\n"
          },
          "discarded_nal_count": {
            "type": "integer",
            "description": "Number of discarded NAL units.\n"
          }
        }
      },
      "input_sdi_counters": {
        "type": "object",
        "description": "SDI,HDMI and other raw input counters",
        "properties": {
          "errors_no_signal": {
            "type": "integer",
            "description": "Frames dropped due to 'No signal'."
          },
          "errors_duplicate": {
            "type": "integer",
            "description": "Frame data is duplicated from previous frame because the input was too slow."
          },
          "errors_ts_duplicate": {
            "type": "integer",
            "description": "Frame time is the same as the previous frame."
          },
          "errors_cpu_stall": {
            "type": "integer",
            "description": "The frame was dropped due to too high CPU load."
          },
          "peak_duration_deviation": {
            "type": "integer",
            "description": "Gauge of maximum deviation from the estimated frame duration."
          },
          "avg_recv_duration": {
            "type": "integer",
            "description": "Gauge of average duration of incoming frame calculated in real time."
          },
          "error_lost_audio": {
            "type": "integer",
            "description": "Counter of configured audio sdi channels without samples or non valid."
          },
          "compensated_frames": {
            "type": "integer",
            "description": "Frames injected to fix client-side SDI stream drift."
          }
        }
      },
      "input_agent_counters": {
        "type": "object",
        "description": "Agent counters",
        "properties": {
          "errors_conn_failed": {
            "type": "integer",
            "description": "The agent was unable to open the requested connection. These errors may indicate problems opening the TCP socket on the agent or the remote host is unreacheable."
          },
          "errors_out_of_memory": {
            "type": "integer",
            "description": "These errors indicate that the agent does not have enough memory to establish a connection to the remote host."
          },
          "errors_buffer_overrun": {
            "type": "integer",
            "description": "These errors indicate that the agent does not have enough buffer size to handle outgoing traffic."
          },
          "errors_invalid_request": {
            "type": "integer",
            "description": "These errors indicate that the agent is receiving invalid requests."
          },
          "errors_unknown": {
            "type": "integer",
            "description": "Unknown errors counter."
          }
        }
      },
      "stream_config_input": {
        "type": "object",
        "properties": {
          "inputs": {
            "description": "List of stream inputs. \n***Important:*** A stream without any inputs can receive video frames **only** if backup file is specified.\n",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/stream_input"
                }
              ]
            },
            "type": "array",
            "x-api-allow": [
              "smartcam",
              "watcher-core",
              "vision-config-external",
              "watcher-client",
              "watcher-admin",
              "central-layouter"
            ]
          }
        }
      },
      "stream_input": {
        "oneOf": [
          {
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_input_fake"
              }
            ],
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ]
          },
          {
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_input_file"
              }
            ],
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ]
          },
          {
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_input_rtsp"
              }
            ],
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ]
          },
          {
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_input_publish"
              }
            ],
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ]
          }
        ],
        "x-pattern-discriminator": "url"
      },
      "stream_input_fake": {
        "allOf": [
          {
            "type": "object",
            "title": "Demo source",
            "properties": {
              "url": {
                "description": "URL to get a demo stream.\n",
                "type": "string",
                "format": "input_url",
                "x-api-allow": [
                  "watcher-core",
                  "vision-config-external",
                  "smartcam",
                  "central-layouter"
                ],
                "example": "fake://fake",
                "pattern": "^fake://.*$",
                "x-format-description": "input_url"
              },
              "width": {
                "type": "integer",
                "description": "Width of an artificially created test video stream. \nApplicable to the `fake://fake` URL.\n"
              },
              "height": {
                "type": "integer",
                "description": "Height of an artificially created test video stream. \nApplicable to the `fake://fake` URL.\n"
              },
              "bitrate": {
                "type": "integer",
                "format": "speed",
                "description": "Bitrate of an artificially created test video stream. \nApplicable to the `fake://fake` URL.\n",
                "x-format-description": "speed"
              }
            },
            "required": [
              "url"
            ]
          },
          {
            "$ref": "#/components/schemas/stream_input_base"
          }
        ]
      },
      "stream_input_base": {
        "type": "object",
        "properties": {
          "comment": {
            "description": "Human-readable description of the input.\n",
            "type": "string",
            "example": "This is a test input"
          },
          "source_timeout": {
            "description": "The period of time, in seconds, for which Media Server will wait for new frames until it considers the source as lost.",
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://flussonic.com/doc/add-secondary-source-for-redundancy/#source_timeout"
            },
            "anyOf": [
              {
                "type": "integer",
                "format": "seconds",
                "x-format-description": "seconds"
              },
              {
                "enum": [
                  false
                ],
                "type": "boolean"
              }
            ],
            "example": 20,
            "x-api-allow": [
              "watcher-core"
            ]
          },
          "audio_timeout": {
            "description": "The period of time, in seconds, for which Media Server will wait for new audio frames until it considers the source as lost.",
            "externalDocs": {
              "description": "Find more information here"
            },
            "type": "integer",
            "format": "seconds",
            "example": 20,
            "x-api-allow": [
              "watcher-core"
            ],
            "x-format-description": "seconds"
          },
          "video_timeout": {
            "description": "The period of time, in seconds, for which Media Server will wait for new video frames until it considers the source as lost.",
            "type": "integer",
            "format": "seconds",
            "example": 20,
            "x-api-allow": [
              "watcher-core"
            ],
            "x-format-description": "seconds"
          },
          "max_retry_timeout": {
            "description": "The maximum time that Media Server will set for attempts to reconnect to source when source problems occur.\nThe time between attempts is not linear and may increase if source problems are not fixed. This parameter limits this value, but the time itself between attempts may be longer.\n",
            "type": "integer",
            "format": "seconds",
            "example": 30,
            "minimum": 1,
            "x-api-allow": [
              "watcher-core"
            ],
            "x-format-description": "seconds"
          },
          "timeout": {
            "description": "The time, in seconds, for Media Server to switch to the fallback source if the main source stops sending frames (video or audio). \nThe important thing here is that the source remains active (connected), allowing for a client-publisher to stay on the socket.\n",
            "type": "integer",
            "example": 10,
            "x-api-allow": [
              "watcher-core"
            ]
          },
          "frames_timeout": {
            "description": "Specifies the period of time, in seconds, for which Media Server waits for new frames to come from the data source before it generates the `frames_timed_out` event that informs you that the source might soon be lost. \nThis period of time must be smaller than `source_timeout`. \nIf frames come again from this source, before `source_timeout` has passed, Media Server issues the `frames_restored` event.\n",
            "type": "integer",
            "example": 3,
            "x-api-allow": [
              "watcher-core"
            ]
          },
          "priority": {
            "description": "The priority that Media Server takes into account when switching to another source.\nThe source with `priority=1` has the first priority, the source with `priority=2` has the second priority, and so on.\n\nBy default, the first source in the list has the highest priority and the last source in the list has the lowest priority. \nIf priority is not specified for some sources, or if some sources have equal priorities, then the default order is applied. \n",
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://flussonic.com/doc/add-secondary-source-for-redundancy/#priority"
            },
            "type": "integer",
            "example": 1,
            "x-api-allow": [
              "watcher-core"
            ]
          },
          "stats": {
            "description": "Detailed runtime information about the input.",
            "allOf": [
              {
                "$ref": "#/components/schemas/input_stats"
              }
            ],
            "readOnly": true,
            "x-api-allow": [
              "watcher-core"
            ]
          },
          "user_agent": {
            "type": "string",
            "description": "User agent. Can be modified if a protocol allows it.",
            "x-api-allow": [
              "watcher-core"
            ]
          },
          "via": {
            "type": "string",
            "format": "agent_url",
            "description": "Agent ID. Used as a proxy to connect to the input server.",
            "x-api-allow": [
              "watcher-core",
              "central-layouter"
            ],
            "x-format-description": "agent://ID identification for `via` configuration option\n"
          },
          "output_audio": {
            "description": "Enables transcoding of the published audio to another codec.\nThe option is useful when you want to get an AAC audio track from WebRTC publish with OPUS or RTSP camera with PCMU.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/output_audio"
              }
            ],
            "x-api-allow": [
              "watcher-core"
            ]
          },
          "headers": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "description": "Request headers as key-value pairs.",
            "example": {
              "User-Agent": "curl/7.85.0",
              "Authorization": "Basic dXNlcjpwYXNzd29yZA=="
            },
            "x-api-allow": [
              "watcher-core"
            ]
          },
          "no_clients_reconnect_delay": {
            "type": "integer",
            "description": "Skip input start if the stream has no clients."
          },
          "allow_if": {
            "type": "string",
            "description": "Path to a file. The input will be allowed if you put `1` in the file, or denied if `0` (reverse logic to `deny_if`).\nThis option allows you to manage inputs without API requests.\n\nFor example, your stream has two inputs and you set `allow_if = /path/to/file` for the first input.\nThe `/path/to/file` file contains only the digit `1`. That means that the first input is used when you play the stream.\nWhen you put `0` to the `/path/to/file` file, the first input is denied, so the second one is played.\n\nIf no such file, the input is allowed.\n"
          },
          "deny_if": {
            "type": "string",
            "description": "Path to a file. The input will be denied if you put `1` in the file, or allowed if `0` (reverse logic to `allow_if`).\nThis option allows you to manage inputs without API requests.\n\nFor example, your stream has two inputs and you set `deny_if = /path/to/file` for the first input.\nThe `/path/to/file` file contains only the digit `1`. \nThat means that the first input will not be used when you play the stream, so the second one will.\nWhen you put `0` to the `/path/to/file` file, the first input is allowed to be played.\n\nIf no such file, the input is allowed.\n"
          }
        }
      },
      "output_audio": {
        "type": "string",
        "oneOf": [
          {
            "title": "Keep",
            "const": "keep",
            "description": "Keep the original audio codec."
          },
          {
            "title": "AAC",
            "const": "aac",
            "description": "Keep AAC if available or transcode to AAC; delete other tracks if any."
          },
          {
            "title": "Add_AAC",
            "const": "add_aac",
            "description": "Add AAC if it was not available already while keeping the original track."
          },
          {
            "title": "AAC silence",
            "const": "aac_silence",
            "description": "Make silence in audio track by using AAC codec. Replace original non-AAC track to AAC."
          },
          {
            "title": "Keep silence",
            "const": "keep_silence",
            "description": "Make silence in audio track by using original audio codec."
          }
        ]
      },
      "stream_input_file": {
        "allOf": [
          {
            "type": "object",
            "title": "File",
            "properties": {
              "url": {
                "description": "URL to get a stream from file.\n",
                "type": "string",
                "format": "input_url",
                "x-api-allow": [
                  "watcher-core",
                  "vision-config-external",
                  "smartcam",
                  "central-layouter"
                ],
                "example": "file://vod/bunny.mp4",
                "pattern": "^file://.*$",
                "x-format-description": "input_url"
              }
            },
            "required": [
              "url"
            ]
          },
          {
            "$ref": "#/components/schemas/stream_input_mpegts_specific"
          },
          {
            "$ref": "#/components/schemas/stream_input_base"
          }
        ]
      },
      "stream_input_mpegts_specific": {
        "type": "object",
        "properties": {
          "programs": {
            "description": "Choose a program to ingest from an MPEG-TS stream.",
            "items": {
              "type": "integer"
            },
            "type": "array",
            "example": [
              1
            ]
          },
          "pids": {
            "description": "Choose a specific PID to ingest from an MPEG-TS stream. \nPID identifies separate data stream inside the multiplexed MPEG-TS stream. \nIt is possible to set PID values for PMT, SDT, video, and audio tracks.\n",
            "items": {
              "type": "integer"
            },
            "type": "array",
            "example": [
              211
            ]
          },
          "subtitles": {
            "description": "This configuration is deprecated. Use `dvbocr` configuration field in stream.\n\nThis parameter allows to manage subtitles in an output stream.\n",
            "oneOf": [
              {
                "const": "drop",
                "description": "An output stream will have no subtitles track."
              },
              {
                "const": "accept",
                "description": "An output stream will have a subtitles track in DVB, without conversion to text (default behavior)."
              },
              {
                "const": "ocr_replace",
                "description": "An output stream will have a track containing subtitles converted to a text format (WebVTT)."
              },
              {
                "const": "ocr_add",
                "description": "An output stream will have two tracks containing subtitles: \nthe original track with subtitles in DVB and a new track with text subtitles.\n"
              }
            ],
            "example": "drop",
            "deprecated": true,
            "x-delete-at": 25.03
          },
          "closed_captions": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "x-key-type": "string",
            "description": "The rules for handling the closed captions.\n"
          },
          "scte35": {
            "description": "This option disables processing of SCTE-35 markers from an MPEG-TS input stream.\nDeprecated since 22.12.\nAvailable ways to disable processing of SCTE-35 markers:\n1. pids option to select tracks without SCTE-35 markers\n2. hls_scte35 option from stream_config_media for hls output\n3. performing appropriate tuning pids in the transponder\n",
            "type": "boolean",
            "default": true,
            "example": true,
            "deprecated": true,
            "x-delete-at": 23.09
          },
          "languages": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "x-key-type": "mpegts_lang_track",
            "description": "An array of MPEG-TS language descriptors in format `[{key: track, value: language}]`\n"
          }
        }
      },
      "stream_input_rtsp": {
        "allOf": [
          {
            "type": "object",
            "title": "RTSP",
            "properties": {
              "url": {
                "description": "URL to connect to the RTSP source and get the stream.\n",
                "type": "string",
                "format": "input_url",
                "x-api-allow": [
                  "watcher-core",
                  "vision-config-external",
                  "smartcam",
                  "central-layouter"
                ],
                "examples": {
                  "default": {
                    "value": "rtsp://remote.host.com/example"
                  },
                  "secure": {
                    "value": "rtsps://remote.host.com/example"
                  },
                  "rtsp-udp": {
                    "value": "rtsp-udp://remote.host.com/example"
                  },
                  "rtsp2": {
                    "value": "rtsp2://remote.host.com/example"
                  }
                },
                "pattern": "^(rtsp|rtsps|rtsp-udp|rtsp2)://.*$",
                "x-format-description": "input_url"
              },
              "rtp": {
                "enum": [
                  "udp"
                ],
                "type": "string",
                "description": "Whether to force UDP to capture a video from RTSP cameras.",
                "x-api-allow": [
                  "watcher-core"
                ]
              },
              "wait_rtcp": {
                "type": "boolean",
                "description": "Whether to wait for the full RTP time synchronization before the processing of frames from the RTSP camera.\n",
                "x-api-allow": [
                  "watcher-core"
                ]
              }
            },
            "required": [
              "url"
            ]
          },
          {
            "$ref": "#/components/schemas/stream_input_base"
          }
        ]
      },
      "stream_input_srt_publish_specific": {
        "type": "object",
        "properties": {
          "subtitles": {
            "description": "This configuration is deprecated. Use `dvbocr` configuration field in stream.\n\nThis parameter allows to manage subtitles in an output stream.\n",
            "oneOf": [
              {
                "const": "drop",
                "description": "An output stream will have no subtitles track."
              },
              {
                "const": "accept",
                "description": "An output stream will have a subtitles track in DVB, without conversion to text (default behavior)."
              },
              {
                "const": "ocr_replace",
                "description": "An output stream will have a track containing subtitles converted to a text format (WebVTT)."
              },
              {
                "const": "ocr_add",
                "description": "An output stream will have two tracks containing subtitles: \nthe original track with subtitles in DVB and a new track with text subtitles.\n"
              }
            ],
            "example": "drop",
            "deprecated": true,
            "x-delete-at": 25.03
          },
          "scte35": {
            "description": "This option disables processing of SCTE-35 markers from SRT input stream.\n",
            "type": "boolean",
            "default": true,
            "example": true
          }
        }
      },
      "stream_input_publish": {
        "allOf": [
          {
            "type": "object",
            "title": "Publish",
            "properties": {
              "url": {
                "description": "The publish:// URL used to indicate where this stream started in publish mode.\n\nYou can publish videos to Flussonic using the following URLs:  \n  __RTSP__: rtsp://FLUSSONIC-IP/stream_name  \n  __HTTP MPEG-TS__: http://FLUSSONIC-IP/stream_name/mpegts  \n  __RTMP__: rtmp://flussonic-ip/published or rtmp://flussonic-ip/static/published  \n  __WebRTC__: http://FLUSSONIC-IP/stream_name/whip  \n  __SRT__: srt://FLUSSONIC-IP:SRT_PORT?streamid=#!::r=STREAM_NAME,m=publish\n",
                "type": "string",
                "format": "input_url",
                "x-api-allow": [
                  "watcher-core",
                  "vision-config-external",
                  "smartcam",
                  "central-layouter"
                ],
                "example": "publish://",
                "pattern": "^publish://.*$",
                "x-format-description": "input_url"
              }
            },
            "required": [
              "url"
            ]
          },
          {
            "$ref": "#/components/schemas/stream_input_webrtc_publish_specific"
          },
          {
            "$ref": "#/components/schemas/stream_input_srt_publish_specific"
          },
          {
            "$ref": "#/components/schemas/stream_input_base"
          }
        ]
      },
      "stream_input_webrtc_publish_specific": {
        "type": "object",
        "title": "WebRTC",
        "properties": {
          "prefer_codec": {
            "description": "Choose one of the listed video codecs at the start of the publication via WebRTC.\n",
            "deprecated": true,
            "x-delete-at": 24.11,
            "x-alias": "prefer_video_codec",
            "allOf": [
              {
                "$ref": "#/components/schemas/webrtc_prefer_video_codec"
              }
            ],
            "example": "av1"
          },
          "prefer_video_codec": {
            "description": "Prefer one of the listed video codecs at the start of the publication via WebRTC.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/webrtc_prefer_video_codec"
              }
            ],
            "example": "av1"
          },
          "transport": {
            "description": "Choose the prefered transport of the publication via WebRTC: UDP or TCP.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/webrtc_transport"
              }
            ],
            "example": "udp"
          },
          "min_bitrate": {
            "description": "The minimum bitrate threshold, in kbit/s. The default value is 100 kbit/s.",
            "type": "integer",
            "example": 150
          },
          "webrtc_abr": {
            "description": "Whether the adaptive bitrate mechanism is used for WebRTC publications.",
            "type": "boolean",
            "example": true
          },
          "abr_stepup": {
            "description": "Increment step for raising the bitrate to the maximum, in percent. The default step is 30%. \nIf the loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup percent`.\n",
            "type": "integer"
          },
          "abr_correction": {
            "description": "The correction between the target bitrate (Receiver Estimated Maximum Bitrate, calculated in Flussonic) and browser bitrate, in kbit/s.\nFlussonic sends the target bitrate to the browser from which the publication is carried out so that the browser adjusts the bitrate of the publication by this value.\nThe default value is 300 kbit/s.\n",
            "type": "integer",
            "example": 200
          },
          "abr_loss_lower": {
            "type": "number",
            "description": "The lower limit of packet loss. When it is reached, Flussonic raises the bitrate. \nThat is, if packet loss is less than `abr_loss_lower`, Flussonic makes the publisher to step up from the current bitrate to the maximum one with the rate of `abr_stepup` percent.\n",
            "example": 2
          },
          "abr_loss_upper": {
            "description": "The upper limit of packet loss. When it is reached, Flussonic reduces the bitrate. \nThat is, if packet loss is greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.\n",
            "type": "number",
            "example": 10
          },
          "abr_stepdown": {
            "description": "A step of reducing the bitrate to the minimum. \nIf packet losses are greater than `abr_loss_upper`, Flussonic makes the publisher to reduce the current bitrate in steps with the maximum rate of `abr_stepdown` percent.\n",
            "type": "number"
          },
          "abr_mode": {
            "description": "The algorithm for determining the need to change the bitrate of the published stream and for calculating the target bitrate. \nTwo options are possible:\n\n* `abr_mode=0` - This mode takes into account the packet losses, target bitrate, browser bitrate and the number of auto-adjustment cycles.\n* `abr_mode=1` - This mode considers only packet losses and target bitrate.\n",
            "type": "integer",
            "example": 1
          },
          "abr_debug": {
            "description": "Whether adaptive bitrate process is logged.",
            "type": "integer",
            "example": 1
          },
          "abr_cycles": {
            "description": "The number of cycles of bitrate auto-adjustment.\nAfter the specified number of auto-adjustment cycles passes, Flussonic considers the bitrate to be optimal, and it is no longer analyzed. \nBy default, `abr_cycles`=5. \nIf `abr_cycles`=0, the adjustment process takes place all the time while the publication lasts.\n",
            "type": "integer",
            "example": 3
          },
          "abr_max_bitrate": {
            "description": "Maximum bitrate for adjustment process, in kbit/s.\nFlussonic will keep the publication bitrate equal or below of the specified value.\n",
            "type": "integer",
            "default": 2500,
            "example": 1000
          }
        }
      },
      "webrtc_prefer_video_codec": {
        "type": "string",
        "enum": [
          "h264",
          "av1"
        ]
      },
      "webrtc_transport": {
        "type": "string",
        "oneOf": [
          {
            "title": "UDP",
            "const": "udp"
          },
          {
            "title": "TCP",
            "const": "tcp"
          }
        ]
      },
      "vision_spec": {
        "type": "object",
        "properties": {
          "alg": {
            "description": "The algorithm used for video analytics.\n",
            "type": "string",
            "oneOf": [
              {
                "const": "faces",
                "description": "The algorithm for face recognition is used."
              },
              {
                "const": "plates",
                "description": "The algorithm for license plate recognition is used."
              }
            ],
            "example": "faces",
            "x-api-allow": [
              "vision-config-external",
              "vision",
              "central",
              "watcher-admin",
              "watcher-client"
            ]
          },
          "areas": {
            "description": "This parameter allows you to select specific polygonal area(s) for detection.\nBy default, it is empty, and the recognition system searches over the entire camera field of view.\n\nEach area is specified as a sequence of comma-separated coordinates of vertices of the polygon: `x0,y0,x1,y1,x2,y2,...`.\nThe vertices are specified in a counter-clockwise direction. Multiple areas are separated by `:`.\n",
            "type": "string",
            "x-api-allow": [
              "vision-config-external",
              "vision",
              "central",
              "watcher-admin",
              "watcher-client"
            ]
          },
          "detectors": {
            "description": "Configuration of videoanalytics modules.\nThis configuration supersedes `alg` and `areas` parameters.  \nIf this field is specified, values of `alg` and `areas` fields are being ignored.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/vision_detector_config"
            },
            "x-api-allow": [
              "smartcam",
              "iris-hal",
              "iris-web",
              "vision",
              "vision-config-external",
              "central",
              "watcher-admin",
              "watcher-client"
            ]
          }
        }
      },
      "vision_detector_config": {
        "type": "object",
        "required": [
          "detector_type",
          "region_id"
        ],
        "properties": {
          "detector_type": {
            "allOf": [
              {
                "description": "Detection module"
              },
              {
                "$ref": "#/components/schemas/vision_detector"
              }
            ]
          },
          "region_title": {
            "type": "string",
            "description": "Name of the detection area",
            "example": "Zone 1"
          },
          "region_id": {
            "type": "string",
            "description": "Identifier of the detection area.\nIt is used to distinguish episodes from various regions of interest within the frame.\nFor instance, it can be used with a single camera facing two entrances to count visitors independently at each entrance.\n"
          },
          "region_coordinates": {
            "allOf": [
              {
                "description": "This parameter allows you to select specific polygonal area(s) to detect objects in.\nThe vertices are specified in a counter-clockwise direction.\n"
              },
              {
                "$ref": "#/components/schemas/vision_region"
              }
            ]
          },
          "stats": {
            "description": "Runtime information about the vision process.",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_detector_stats"
              }
            ],
            "readOnly": true
          }
        }
      },
      "vision_detector": {
        "type": "string",
        "oneOf": [
          {
            "title": "Face detector",
            "const": "faces"
          },
          {
            "title": "Vehicle and license plate detector",
            "const": "vehicles"
          },
          {
            "title": "Motion detector (SAD or similar type)",
            "const": "motion"
          },
          {
            "title": "QR detector",
            "const": "qr-codes"
          },
          {
            "title": "Humans",
            "const": "humans"
          }
        ]
      },
      "vision_region": {
        "type": "array",
        "description": "region",
        "items": {
          "$ref": "#/components/schemas/vision_point"
        },
        "minItems": 3
      },
      "vision_point": {
        "type": "object",
        "description": "2D point",
        "required": [
          "x",
          "y"
        ],
        "properties": {
          "x": {
            "description": "X coordinate. Fraction of full frame width",
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "examples": {
              "default": {
                "value": 0.54
              },
              "one": {
                "value": 0.78
              }
            }
          },
          "y": {
            "description": "Y coordinate. Fraction of full frame height",
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "examples": {
              "default": {
                "value": 0.38
              },
              "one": {
                "value": 0.12
              }
            }
          }
        }
      },
      "vision_detector_stats": {
        "type": "object",
        "properties": {
          "last_detection_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The time when there was the last detection. Constant updates mean that analytics can detect objects on frames.",
            "example": 1637094994000,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "alerts": {
            "description": "Identifies analytics issues related to frames in a stream that impact episode creation\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_alerts"
              }
            ]
          }
        }
      },
      "vision_alerts": {
        "type": "object",
        "properties": {
          "low_quality_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The time when an episode could not be created due to low detection quality (on blurry or noisy frames).\nIt may be caused by uncertainty when the picture is not clear enough.\nTry adjusting the shutter speed parameters on your camera.\n",
            "example": 1637094994000,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "small_size_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The time when an episode could not be created due to the small size of detections relative to the detector internal settings.\nThe camera placement may need to be adjusted closer to the target objects.\n",
            "example": 1637094994000,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "not_enough_detections_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The time when an episode could not be created due to insufficient detections.\nThe issue occurs when the selected detector is unable to find the target object enough times.\nIt is possible that the target object appears shortly or is obscured by something. \n",
            "example": 1637094994000,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          }
        }
      },
      "stream_dvr_specific_spec": {
        "type": "object",
        "properties": {
          "redundancy_factor": {
            "description": "How many servers will contain a copy of the DVR archive.\nYou can find more information [here](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cdvr%7Credundancy_factor)\n",
            "x-api-description": {
              "central-layouter": "How many servers will contain a copy of the DVR archive.\nLayouter will select nodes to copy the stream archive based on the load of the node, [namespace](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cnamespace) and [labels](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clabels).\nThe hostname of the selected nodes will be contained in the [layout.dvr_backup](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Clayout%7Cdvr_backup) field\n"
            },
            "type": "integer",
            "example": 1,
            "minimum": 0,
            "x-api-allow": [
              "central-layouter"
            ]
          }
        }
      },
      "dvr_base_config": {
        "type": "object",
        "properties": {
          "storage_limit": {
            "description": "Maximum disk consumption in bytes. When this limit is reached, \nthe oldest segment of the recording will be overridden by later data.\n\nThis option affects both continuous recording and locked episodes (see `episodes_url`).\n\nIf `episodes_url` does not respond, the archive clean-up by `storage_limit` is not performed\nto avoid deleting the recordings that should not be deleted.\n",
            "type": "integer",
            "format": "bytes",
            "example": 400000000000,
            "x-format-description": "bytes"
          },
          "expiration": {
            "description": "Archive depth - a period (in seconds) back from the current moment during which the \ncontigious part of archive is stored. \nAs time goes, the parts of the recording which are older than the archive depth are deleted.\n\nIf you have option `episodes_expiration` enabled, then some parts of DVR that are \nlocked by episode signalling mechanism may be kept more than this `expiration` depth.\n\nIf `episodes_url` does not respond, the archive clean-up by `expiration` is not performed;\nonly the archive with expired episodes (`episodes_expiration`) is cleaned up until the `episodes_url` restores.\n",
            "type": "integer",
            "format": "seconds",
            "examples": {
              "default": {
                "value": 604800
              }
            },
            "x-api-allow": [
              "central-layouter"
            ],
            "x-format-description": "seconds"
          },
          "episodes_expiration": {
            "description": "Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record\nwill be saved for `expiration + episodes_expiration` seconds.\n\nThe archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the\nrecording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)\nresponse of `episodes_url`.\n\nAnything older than `expiration+episodes_expiration` seconds will\nbe cleaned even if `episodes_url` does not respond.\n",
            "type": "integer",
            "format": "seconds",
            "examples": {
              "default": {
                "value": 6048000
              }
            },
            "x-api-allow": [
              "central-layouter"
            ],
            "x-api-description": {
              "central-layouter": "Additional archive depth in seconds for episodes. If set, episodes and their corresponding DVR record\nwill be saved for `expiration + episodes_expiration` seconds.\n\nThe archive clean-up within `[expiration, expiration+episodes_expiration]` seconds of the\nrecording performed depending on [external_episodes_list](https://flussonic.com/doc/api/config-external/#tag/dvr/operation/external_episodes_list)\nresponse of `episodes_url`.\n\nAnything older than `expiration+episodes_expiration` seconds will\nbe cleaned even if `episodes_url` does not respond.\n\nLayouter uses this field to calculate the potential archive size of the stream when\n[episodes_density](https://flussonic.com/doc/api/layouter/#tag/stream/operation/streams_list/response%7Cstreams%7Cstats%7Cepisodes_density)\nis set and greater than 0.\n"
            },
            "x-format-description": "seconds"
          }
        }
      },
      "on_off": {
        "type": "object",
        "properties": {
          "mode": {
            "oneOf": [
              {
                "const": "on",
                "title": "On",
                "description": "The system is turned on"
              },
              {
                "const": "off",
                "title": "Off",
                "description": "The system is turned off"
              }
            ]
          }
        }
      },
      "on_off_auto": {
        "type": "object",
        "properties": {
          "mode": {
            "oneOf": [
              {
                "const": "on",
                "title": "On",
                "description": "The system is turned on"
              },
              {
                "const": "off",
                "title": "Off",
                "description": "The system is turned off"
              },
              {
                "const": "auto",
                "title": "Auto",
                "description": "The system automatically adjusts based on conditions"
              }
            ]
          }
        }
      },
      "thumbnails_enabled_spec": {
        "oneOf": [
          {
            "type": "boolean",
            "enum": [
              true,
              false
            ],
            "description": "Configures thumbnails behaviour.\n- true : \n\n    In case of Stream: \n      Thumbnails are created and stored in DVR during the recording. If thumbnail is requested then it will be returned from DVR.\n\n    In case of VOD:\n      Thumbnails are created and stored in VOD location at thumbnails folder during the VOD opening if they are not created yet.\n      If VOD location is `readonly` then it will be used only for thumbnails searching. Nothing will be created and stored.  \n\n      If thumbnail is requested then it will be returned from thumbnails folder in VOD location.\n\n- false : thumbnails are not stored at all. If thumbnail is requested then 403 'Forbidden' error will be returned.\n"
          },
          {
            "type": "string",
            "enum": [
              "ondemand"
            ],
            "description": "- ondemand : thumbnails are not stored at all. If thumbnail is requested then it will be generated from corresponding video frame.\n"
          }
        ]
      },
      "episode_generic": {
        "allOf": [
          {
            "$ref": "#/components/schemas/episode_base"
          },
          {
            "type": "object",
            "properties": {
              "episode_type": {
                "type": "string",
                "description": "Generic stream episode",
                "const": "generic"
              }
            }
          }
        ]
      },
      "episode_base": {
        "type": "object",
        "description": "# Definition\n\nEpisode is a record about continious part of one video stream.\n\nIt is used in video analytics, television systems, etc. for describing one continious and logically\nconsolidated part of video stream.\n\nFor example, episode can describe one TV show or a part of video when the car with specific license plate\npassed the camera view.\n\nDifferent systems in our ecosystem can emit and consume episodes of different `episode_type`.\n\n# Alternatives\n\nWhat episodes are not:\n\n  * they cannot combine multiple streams. If you have multicamera view on the scene, you will have to create many episodes and join then in another system\n  * they cannot be multipart. Only one continious uninterrupted episode. However, it is ok for them to overlap.\n\n# Updates\n\nEpisodes are supposed to be streamable and updatable. \n\nIf you consume episodes, you must be ready to see old `episode_id`\nwith new updated data. You MUST overwrite previous data.\n\nIf you emit episodes and you change any fields, you MUST accumulate previous data of episode and send full copy of\nupdated episode.\n\n# Borders\n\nEpisode have two mandatory fields: `opened_at` and `updated_at`, they are default borders of the episode:\nbeginning and the end.\n\nSometimes you need to look at another fields: `started_at` and `closed_at`.\n\n`started_at` appears when episode emitter decides that beginning of the episode should be different from `opened_at`,\nfor example if video analytics has analysed previous frames and decided that this object appeared earlier.\n\n`closed_at` can appear if episode source have decided that episode will not continue anymore, for example\ncar have run out of camera view. However, `updated_at` can be still changed, if any other system will add \nmore data there, for example detected licence plates of some other auxiliary information.\n",
        "required": [
          "episode_id",
          "media",
          "opened_at",
          "updated_at"
        ],
        "properties": {
          "episode_id": {
            "type": "integer",
            "format": "snowflake_id",
            "description": "Unique identifier of the episode. Must be created by the system that first creates this episode.\n\nPlease, mention that it is assumed to be 64 bit length including time of creation in it (refer to snowflake),\nso you cannot handle it in javascript with simple `JSON.parse()`, you need to use parsed that will properly\nhandle very long integers.\n",
            "examples": {
              "default": {
                "value": 1722279170848854000
              }
            },
            "x-format-description": "snowflake_id"
          },
          "media": {
            "type": "string",
            "format": "media_name",
            "description": "Stream name on which this episode exists.\n",
            "x-format-description": "media_name"
          },
          "close_reason": {
            "description": "The reason for closing the episode.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/episode_close_reason"
              }
            ]
          },
          "opened_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The time when this episode was created. Naming is standard for whole flussonic ecosystem.\nUsually this time will be the same as `started_at`, but can differ, refer to the description of that field.\n\nThe value of this field is copied into `episode_id`, so sorting by `episode_id` will give you the same\nsort as by `opened_at`\n",
            "examples": {
              "default": {
                "value": 1637094994000
              }
            },
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "started_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "This field can be used as indication of the fact that some system have checked and ensured that\nthis episode has really started at some time, that may differ from `opened_at`.\n\nFor example video analytics will use this field for the time when this episode was confirmed as confident.\n\nMay be not relevant for television systems.\n",
            "examples": {
              "default": {
                "value": 1637094994000
              }
            },
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "updated_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The time of last change of the episode.\n\nSystem that processes episodes and can send them to other systems, MUST update this field\non any changes in this episode.\n\nThis field MUST be updated strictly monotonical and increasing. The updater MUST guarantee that\nthis `updated_at` can be used as a sort key for fetching fresh updates.\n\nConsumer of the episodes can use `updated_at` in the following scenario:\n\n  * fetch all exisiting episodes from the source\n  * take biggest `updated_at` from this dataset, it will be T\n  * ask source for all episodes with `updated_at > T`\n\nThis algorithm can be used for fetching update stream from the source.\n",
            "examples": {
              "default": {
                "value": 1637098611000
              }
            },
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "closed_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "Episode emitter can decide that episode considered closed and will not grow further.\n`closed_at` MUST NOT change, it must be emitted only once.\n\nEpisode can live without `closed_at`, in this case you should use `updated_at` as the last time\nof the episode.\n",
            "examples": {
              "default": {
                "value": 1637094994000
              }
            },
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "preview_timestamp": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The time when the preview of this episode is available.\nUse it to request preview image via Mediaserver's DVR API (`jpeg_preview_dvr`).\n\nVisit the [Getting JPEGs from DVR by specific time](https://flussonic.com/doc/thumbnails/#thumbnails-dvr-time) article\nand [JPEG thumbnail from DVR](https://flussonic.com/doc/api/streaming/#tag/image/operation/jpeg_preview_dvr) section of the Mediaserver's API Reference\nfor details.\n\nThis field may not be present. If so, you may use the timestamp from the `started_at` field to request the preview image\n",
            "examples": {
              "default": {
                "value": 1637094994000
              }
            },
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "preview": {
            "type": "string",
            "contentEncoding": "base64",
            "format": "base64",
            "description": "Small inline image of detected object cropped from the entire frame used for directly display in web-browser UI or mobile application.\n",
            "x-format-description": "base64"
          },
          "frame_preview": {
            "type": "string",
            "contentEncoding": "base64",
            "format": "base64",
            "description": "Small inline image of the entire frame used for direct display in web-browser UI or mobile application.\n\nFrame preview resolution is about 240p and the maximum image size is not larger then a few tens of kilobytes.\n",
            "x-format-description": "base64"
          },
          "episode_appearance_timestamps": {
            "description": "The time when the episode appeared in the service relative to the server time.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/episode_appearance_timestamps"
              }
            ]
          }
        }
      },
      "episode_close_reason": {
        "type": "string",
        "oneOf": [
          {
            "title": "Timeout",
            "description": "Episode was closed because of no activity was detected in it.",
            "const": "timeout"
          }
        ]
      },
      "episode_appearance_timestamps": {
        "type": "object",
        "properties": {
          "inference_timestamp": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The time when this episode was created in inference service.",
            "example": 1637094994000,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "central_timestamp": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The time when this episode was fetched by Central.",
            "example": 1637098611000,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "watcher_timestamp": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The time when this episode was fetched by Watcher.",
            "example": 1637094994000,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          }
        }
      },
      "vision_episode_human": {
        "allOf": [
          {
            "$ref": "#/components/schemas/episode_base"
          },
          {
            "type": "object",
            "properties": {
              "episode_type": {
                "type": "string",
                "description": "Human is detected",
                "const": "human"
              },
              "detections": {
                "type": "array",
                "description": "Detections associated with this episode",
                "items": {
                  "$ref": "#/components/schemas/vision_detected_object_base"
                }
              }
            }
          }
        ]
      },
      "vision_detected_object_base": {
        "type": "object",
        "required": [
          "detected_at",
          "object_class"
        ],
        "properties": {
          "detected_at": {
            "description": "Timestamp when the object was detected",
            "type": "integer",
            "format": "utc_ms",
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "object_class": {
            "description": "Class of the detected object",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_object_class"
              }
            ]
          },
          "appearance": {
            "description": "Appearance attributes of the detected object",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_appearance"
              }
            ]
          },
          "confidence": {
            "description": "Confidence level of object detection",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_confidence"
              }
            ]
          },
          "thumbnail_quality": {
            "description": "Quality of the thumbnail",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_confidence"
              }
            ]
          },
          "thumbnail": {
            "description": "Preview of the detected object",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_image_attributes"
              }
            ]
          }
        }
      },
      "vision_object_class": {
        "type": "string",
        "description": "Object class",
        "oneOf": [
          {
            "title": "Face",
            "const": "face"
          },
          {
            "title": "License plate",
            "const": "license_plate"
          },
          {
            "title": "Vehicle",
            "const": "vehicle"
          },
          {
            "title": "Human",
            "const": "human"
          }
        ]
      },
      "vision_appearance": {
        "type": "object",
        "properties": {
          "box": {
            "description": "Position of the objects at the frame",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_box"
              }
            ]
          }
        }
      },
      "vision_box": {
        "type": "object",
        "description": "Rectangle",
        "required": [
          "top",
          "left",
          "bottom",
          "right"
        ],
        "properties": {
          "top": {
            "description": "Top border of the bounding box. Fraction of full frame height",
            "type": "number",
            "minimum": 0,
            "maximum": 1
          },
          "left": {
            "description": "Left border of the bounding box. Fraction of full frame width",
            "type": "number",
            "minimum": 0,
            "maximum": 1
          },
          "bottom": {
            "description": "Bottom border of the bounding box. Fraction of full frame height",
            "type": "number",
            "minimum": 0,
            "maximum": 1
          },
          "right": {
            "description": "Right border of the bounding box. Fraction of full frame width",
            "type": "number",
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "vision_confidence": {
        "description": "Confidence metric",
        "type": "number",
        "examples": {
          "default": {
            "value": 0.34
          },
          "one": {
            "value": 0.98
          }
        },
        "minimum": 0,
        "maximum": 1
      },
      "vision_episode_context_search": {
        "allOf": [
          {
            "$ref": "#/components/schemas/episode_base"
          },
          {
            "type": "object",
            "properties": {
              "episode_type": {
                "type": "string",
                "description": "Episode matches context search text query",
                "const": "context_search"
              },
              "match_score": {
                "type": "number",
                "description": "Maximum matching score between the text query and episode.",
                "examples": {
                  "default": {
                    "value": 0.2345
                  }
                }
              }
            }
          }
        ]
      },
      "vision_detected_face": {
        "allOf": [
          {
            "$ref": "#/components/schemas/vision_detected_object_base"
          },
          {
            "$ref": "#/components/schemas/vision_face_attributes"
          },
          {
            "type": "object",
            "description": "Detected face"
          }
        ]
      },
      "vision_face_attributes": {
        "type": "object",
        "properties": {
          "fingerprint": {
            "description": "The fingerprint of the detected face",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_face_fingerprint"
              }
            ]
          }
        }
      },
      "vision_face_fingerprint": {
        "type": "object",
        "description": "Digital fingerprint of the face",
        "required": [
          "data",
          "version"
        ],
        "properties": {
          "data": {
            "description": "Base64 encoded representation of the fingerprint",
            "type": "string",
            "format": "base64",
            "x-format-description": "base64"
          },
          "version": {
            "description": "Version identifier of the fingerprint's data. The version is assigned automatically.\nFingerprints of different versions cannot be compared to each other.\n",
            "type": "string",
            "examples": {
              "default": {
                "value": "aabbccdd"
              },
              "one": {
                "value": "c6ba4246"
              }
            }
          }
        }
      },
      "vision_episode_qr_code": {
        "allOf": [
          {
            "$ref": "#/components/schemas/episode_base"
          },
          {
            "type": "object",
            "properties": {
              "episode_type": {
                "type": "string",
                "description": "QR-code is detected",
                "const": "qr_code"
              },
              "payload": {
                "type": "string",
                "description": "Raw data extracted from QR-code",
                "example": "WIFI:T:WPA;S:MyOfficeWiFi;P:Mypassword;H:;"
              }
            }
          }
        ]
      },
      "episode_custom": {
        "allOf": [
          {
            "$ref": "#/components/schemas/episode_base"
          },
          {
            "type": "object",
            "properties": {
              "episode_type": {
                "type": "string",
                "description": "Custom episode type.\nUse this field to define your own episode types when integrating custom analytics. \nIf episode type is not specified, episode will be saved with `generic` type.\n",
                "maxLength": 20,
                "minLength": 1
              },
              "payload": {
                "type": "object",
                "description": "Custom episode payload. Use this field to provide additional information about the episode."
              }
            }
          }
        ]
      },
      "vision_person_match": {
        "type": "object",
        "description": "Person matching information",
        "required": [
          "person",
          "match_score"
        ],
        "properties": {
          "person": {
            "description": "Matched person",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_person"
              }
            ]
          },
          "match_score": {
            "description": "Score of the match with person. 1.0 means absolute match",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_confidence"
              }
            ]
          }
        }
      },
      "vision_person": {
        "type": "object",
        "description": "Person",
        "required": [
          "person_id",
          "updated_at",
          "originator"
        ],
        "properties": {
          "person_id": {
            "description": "Identifier of the person",
            "readOnly": true,
            "format": "snowflake_id",
            "type": "integer",
            "examples": {
              "default": {
                "value": 7036001172460667000
              }
            },
            "x-format-description": "snowflake_id"
          },
          "name": {
            "type": "string",
            "description": "The name of the person filled in manually or automatically if not recognized\n",
            "examples": {
              "default": {
                "value": "John Doe"
              },
              "unknown": {
                "value": "Unknown ABC"
              }
            }
          },
          "external_id": {
            "description": "Identifier of the person in the external system. \nUse it when supplying the recognition results further into the external system\n(e.g. for access level check) if the person identifiers in the external system \nare different from the ones in Flussonic Identification database.\n\nThis field may contain `null` when video analytics detects a new person\nwhich explicitly has no association in the external system (i.e. if `originator=identification_service`). \n",
            "type": "string",
            "examples": {
              "default": {
                "value": "dedcc8e8"
              }
            }
          },
          "originator": {
            "description": "Indicates the way this person was created: \nmanually via an api or automatically in the identification service.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_person_originator"
              }
            ]
          },
          "updated_at": {
            "description": "When this person was last updated",
            "type": "integer",
            "format": "utc_ms",
            "example": 1637034282845,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "deleted_at": {
            "description": "When this person was marked as deleted",
            "type": "integer",
            "format": "utc_ms",
            "example": 1637095014573,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "photos": {
            "description": "Person's photos. External system uploads images\nwhich are being processed by videoanalytics\nto get digital fingerprint of the person\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/vision_image_attributes"
            }
          },
          "organization": {
            "description": "Organization information.",
            "allOf": [
              {
                "$ref": "#/components/schemas/organization_base"
              }
            ]
          },
          "person_list": {
            "description": "Person list details",
            "type": "object",
            "properties": {
              "id": {
                "type": "integer",
                "description": "Person list identifier",
                "example": 3
              },
              "name": {
                "type": "string",
                "description": "Person list name",
                "example": "List 1"
              }
            }
          },
          "first_seen_at": {
            "description": "When this person was first seen",
            "type": "integer",
            "format": "utc_ms",
            "example": 1637034282845,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "last_seen_at": {
            "description": "When this person was last seen",
            "type": "integer",
            "format": "utc_ms",
            "example": 1637095014573,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          }
        }
      },
      "vision_detected_vehicle": {
        "allOf": [
          {
            "$ref": "#/components/schemas/vision_detected_object_base"
          },
          {
            "$ref": "#/components/schemas/vision_vehicle_attributes"
          },
          {
            "type": "object",
            "description": "Detected vehicle"
          }
        ]
      },
      "vision_vehicle_attributes": {
        "type": "object",
        "properties": {
          "purpose": {
            "description": "The purpose of the vehicle, e.g. emergency or regular.",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_vehicle_purpose"
              }
            ]
          },
          "license_plate_missing": {
            "type": "boolean",
            "description": "Indicates if no license plate is detected on this vehicle"
          }
        }
      },
      "vision_vehicle_purpose": {
        "description": "The purpose of the vehicle, e.g. emergency or regular.\nPolice, ambulance cars and firetrucks are being detected by the videoanalytics as `emergency`.\nAny other type of vehicle is marked as `regular`.\n",
        "type": "string",
        "oneOf": [
          {
            "title": "Regular",
            "const": "regular",
            "description": "Regular car"
          },
          {
            "title": "Emergency",
            "const": "emergency",
            "description": "Emergency vehicle (police, ambulance or firetruck)"
          }
        ]
      },
      "vision_detected_license_plate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/vision_detected_object_base"
          },
          {
            "$ref": "#/components/schemas/vision_license_plate_attributes"
          },
          {
            "type": "object",
            "description": "Detected license plate"
          }
        ]
      },
      "vision_license_plate_attributes": {
        "type": "object",
        "description": "Attributes of the detected vehicle",
        "properties": {
          "plate_text": {
            "description": "Recognized vehicle's license plate number",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_license_plate_text"
              }
            ]
          },
          "facing_side": {
            "description": "Shows from which side the vehicle was detected.",
            "allOf": [
              {
                "$ref": "#/components/schemas/vision_vehicle_facing_side"
              }
            ]
          }
        }
      },
      "vision_license_plate_text": {
        "description": "Recognized vehicle's license plate number",
        "type": "string",
        "examples": {
          "default": {
            "value": "A123BC45"
          },
          "one": {
            "value": "B98365H"
          },
          "two": {
            "value": "7BTK345"
          }
        }
      },
      "vision_vehicle_facing_side": {
        "description": "Shows from which side the vehicle was detected.",
        "type": "string",
        "oneOf": [
          {
            "title": "Front",
            "const": "front",
            "description": "The vehicle was detected from the front."
          },
          {
            "title": "Rear",
            "const": "rear",
            "description": "The vehicle was detected from the rear."
          }
        ]
      },
      "vision_vehicle_emergency_subtype": {
        "description": "Emergency type of the vehicle, e.g. ambulance, police, firetruck.\n",
        "type": "string",
        "oneOf": [
          {
            "title": "Ambulance",
            "const": "ambulance",
            "description": "ambulance car"
          },
          {
            "title": "Police",
            "const": "police",
            "description": "police car"
          },
          {
            "title": "Firetruck",
            "const": "firetruck",
            "description": "firetruck car"
          }
        ]
      },
      "vision_image_mimetype": {
        "type": "string",
        "oneOf": [
          {
            "const": "image/jpeg",
            "title": "jpeg",
            "description": "jpeg"
          }
        ]
      },
      "ptz_move_continuous": {
        "type": "object",
        "properties": {
          "command": {
            "type": "string",
            "example": "move_continuous",
            "description": "start PTZ continuous move"
          },
          "up": {
            "type": "integer",
            "description": "Speed to move the camera up. Percentage of the maximum pan speed.\n",
            "maximum": 100,
            "minimum": 0,
            "example": 0
          },
          "down": {
            "type": "integer",
            "description": "Speed to move the camera down. Percentage of the maximum pan speed.\n",
            "maximum": 100,
            "minimum": 0,
            "example": 50
          },
          "left": {
            "type": "integer",
            "description": "Speed to move the camera left. Percentage of the maximum tilt speed.\n",
            "maximum": 100,
            "minimum": 0,
            "example": 50
          },
          "right": {
            "type": "integer",
            "description": "Speed to move the camera right. Percentage of the maximum tilt speed.\n",
            "maximum": 100,
            "minimum": 0,
            "example": 0
          },
          "in": {
            "type": "integer",
            "description": "Speed to zoom in the camera. Percentage of the maximum zoom speed.\n",
            "maximum": 100,
            "minimum": 0,
            "example": 20
          },
          "out": {
            "type": "integer",
            "description": "Speed to zoom out the camera. Percentage of the maximum zoom speed.\n",
            "maximum": 100,
            "minimum": 0,
            "example": 0
          }
        }
      }
    },
    "parameters": {
      "select": {
        "name": "select",
        "description": "Comma-separated list of fields (including nested) that will be returned.",
        "explode": false,
        "in": "query",
        "required": false,
        "schema": {
          "example": "episode_id,media,close_reason",
          "type": "string"
        },
        "style": "form"
      },
      "limit": {
        "name": "limit",
        "description": "Limit select count in collection to N elements.",
        "explode": false,
        "in": "query",
        "required": false,
        "schema": {
          "type": "integer",
          "example": 100
        },
        "style": "form"
      },
      "cursor": {
        "name": "cursor",
        "description": "Properly encoded analog of offset, allowing to read next bunch of items.\nWe do not offer common `offset` fields, use please cursor for predictable\nfetching of quickly changing list of items. Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).\n",
        "in": "query",
        "required": false,
        "schema": {
          "type": "string",
          "example": "JTI0cG9zaXRpb25fZ3Q9MQ=="
        }
      },
      "sort": {
        "name": "sort",
        "description": "Composite sort direction.\nDefault sort order is `named_by (config,user,remote)`, `position`, `name`.\n",
        "explode": false,
        "in": "query",
        "required": false,
        "schema": {
          "example": "-stats.bitrate,name,position",
          "type": "string"
        },
        "style": "form"
      },
      "q": {
        "name": "q",
        "description": "Search pattern for different fields like name, title, urls, etc.",
        "in": "query",
        "required": false,
        "schema": {
          "type": "string",
          "example": "somepattern"
        }
      }
    },
    "securitySchemes": {
      "basicAuth": {
        "scheme": "basic",
        "type": "http",
        "description": "To use Basic Auth to authorize API calls, you need a token. \nToken is base64 encoded 'user:password' string.\n"
      },
      "bearerAuth": {
        "bearerFormat": "JWT",
        "scheme": "bearer",
        "type": "http",
        "description": "To use Bearer Auth to authorize API calls, you need a token. \nToken is returned in `/login` (login_create) request as `access_token` parameter.\n"
      },
      "tokenAuth": {
        "type": "apiKey",
        "in": "header",
        "name": "Authorization",
        "description": "The token in the header is taken from shared_token\nIt can be used in the Authorization header as Bearer token.\n"
      }
    }
  },
  "paths": {
    "/login": {
      "post": {
        "operationId": "login_create",
        "summary": "Get an auth token",
        "description": "The method creates a new temporary auth-token (JWT). The JTW token used as Bearer token in requests other than `/login`.\n",
        "responses": {
          "200": {
            "description": "Authorization passed.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/login_info_additional"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The request doesn't have valid authentication credentials (expired, deleted, invalid login or password).\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "403": {
            "description": "Permission denied. The user not having the necessary permissions for a resource.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "auth"
        ]
      }
    },
    "/password_recovery": {
      "post": {
        "operationId": "password_recovery",
        "summary": "Send password recovery email",
        "description": "Send user email with password recovery instructions. This method will return success \nregardless of whether there is a user with the specified email address or not\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/password_recovery"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Email sent\n"
          },
          "400": {
            "description": "No field email in data\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "409": {
            "description": "Captcha validation error\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "auth"
        ]
      }
    },
    "/reset_password": {
      "parameters": [
        {
          "name": "Email-Token",
          "in": "header",
          "schema": {
            "type": "string"
          },
          "required": true,
          "description": "Token that is generated in the backend and inserted to links in email.\nThe purpose is to allow client to reset password without entering code,\njust by following a link with this secret token provided.\nTakes precedence over common authentication.\n"
        }
      ],
      "post": {
        "operationId": "reset_password",
        "summary": "Reset password",
        "description": "Changes user password\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/password_reset"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Password changed\n"
          },
          "400": {
            "description": "No field password in data or no Email-Token in headers\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "401": {
            "description": "Wrong or expired token was used\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "auth"
        ]
      }
    },
    "/streams": {
      "get": {
        "operationId": "streams_list",
        "summary": "List streams",
        "description": "This API method is one of the most important in whole API, because it gives the list of all streams.\n\n`streams_list` in Watcher Admin API:\n* can list all streams within the Watcher.\n* admin is not allowed to watch content from any cameras for security reasons.\n\n`streams_list` in Watcher Client API:\n* return streams from organizations where you're member\n* prodives a playback token that allows play video from the camera.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/select"
          },
          {
            "$ref": "#/components/parameters/sort"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/cursor"
          },
          {
            "$ref": "#/components/parameters/q"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/streams_list"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "stream"
        ]
      }
    },
    "/streams/multiedit": {
      "post": {
        "operationId": "streams_multiedit",
        "summary": "Save streams settings",
        "description": "Create or update settings for each stream.\nThis operation does everything or nothing. If at least one stream has an invalid configuration or can't be processed, the request will fail.\n",
        "requestBody": {
          "description": "Partial stream configuration",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/streams_multiedit_config"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Streams updated successfully"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "No streams could be updated"
          }
        },
        "tags": [
          "stream"
        ]
      }
    },
    "/streams/{name}": {
      "get": {
        "operationId": "stream_get",
        "summary": "Get one stream",
        "description": "This method allows to fetch a single stream. Refer to the `streams_list` operation to find out what data will be returned in this method.",
        "parameters": [
          {
            "description": "Stream name.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stream_config"
                }
              }
            },
            "description": "Whole stream"
          }
        },
        "tags": [
          "stream"
        ]
      },
      "put": {
        "operationId": "stream_save",
        "summary": "Save stream",
        "description": "Create or update a stream by its name.\nIf the stream doesn't exists in the disk config, it will be created.\n\nIf you try to update a stream that is started from a template by a user request\nhaving `named_by=user`, a new stream will be created in the disk config.\n\nIf you pass only a partial stream configuration, this field will be updated, not the whole stream.\n\nTo create a new stream the property `name` is required.\n\nPass the `\"$reset\": true` option to replace the stream configuration with the provided one.\n",
        "parameters": [
          {
            "name": "name",
            "description": "stream name",
            "in": "path",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          },
          {
            "name": "part",
            "description": "The stream is configured by several origins of configuration. It may be `config_on_disk`\nor temporary runtime `config_override` that can be provided via `on_play` or `on_publish`\nbackend, or edited via this API call if you pass `config_override` to this parameter.\n",
            "in": "query",
            "schema": {
              "default": "config_on_disk",
              "type": "string",
              "enum": [
                "config_override",
                "config_on_disk"
              ]
            }
          }
        ],
        "requestBody": {
          "description": "Partial stream configuration",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/stream_config"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Created or updated stream",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stream_config"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Couldn't save"
          }
        },
        "tags": [
          "stream"
        ]
      },
      "delete": {
        "operationId": "stream_delete",
        "summary": "Delete the stream",
        "description": "This method allows to delete a single stream. You can delete `config_override` by this API call if you want\nto remove all runtime overrides.\n\nIf you do not specify any `part` parameter, this stream will be deleted from `config_on_disk`\nand if it was `named_by: config`, then it will immediately stop.\n",
        "parameters": [
          {
            "name": "name",
            "description": "stream name",
            "in": "path",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          },
          {
            "name": "part",
            "description": "part of config to delete",
            "in": "query",
            "schema": {
              "default": "config_on_disk",
              "type": "string",
              "enum": [
                "config_override",
                "config_on_disk"
              ]
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "stream"
        ]
      }
    },
    "/streams/import": {
      "post": {
        "operationId": "streams_import",
        "summary": "Import of streams",
        "description": "This method allows you to easily add or update camera configurations.\nIf a camera with the specified name exists, its settings will be updated; otherwise,\na new camera will be created. This is useful for making simultaneous changes to multiple cameras,\nsuch as integrating billing or setting up different user configurations.\n\nNew cameras will be added or existing ones updated without affecting others.\n\nRequests can be sent in CSV format.\n\nEnsure the user has permission to edit cameras in the relevant organizations before submitting.\n\nIf errors occur, no changes will be made, preserving the original configuration.\n",
        "requestBody": {
          "description": "Streams configurations",
          "content": {
            "text/csv": {
              "schema": {
                "type": "string"
              },
              "example": "name,title,comment,static,disabled,inputs_0_url,inputs_1_url,dvr_expiration,dvr_episodes_expiration,dvr_storage_limit,dvr_redundancy_factor,vision_alg,vision_areas,organization_id,coordinates_latitude,coordinates_longitude,is_test,onvif_ptz\ncam-e7fee73458,Primary camera title,,true,false,rtsp://127.0.0.1/stream/main,rtsp://127.0.0.1/stream/sub,86400,259200,32212254720,3,faces,x1 y1,1,55.71182944518981,37.7775426954031,false,false\n,Secondary camera title,Camera comment,true,false,rtsp://127.0.0.1/stream2/main,rtsp://127.0.0.1/stream2/sub,172800,432000,,0,plates,x2 y2,1,51.711667039488155,35.77733281254769,true,true\n"
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful import of streams.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/streams_import_response"
                }
              }
            }
          },
          "400": {
            "description": "The streams could not be imported.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "stream"
        ]
      }
    },
    "/streams/{name}/ptz": {
      "parameters": [
        {
          "name": "name",
          "description": "stream name",
          "in": "path",
          "required": true,
          "schema": {
            "example": "1",
            "type": "string"
          },
          "style": "simple"
        }
      ],
      "post": {
        "operationId": "stream_ptz_execute",
        "summary": "Execute a PTZ command",
        "x-api-deny": [
          "watcher-core"
        ],
        "description": "Execute a PTZ command\n",
        "requestBody": {
          "description": "PTZ command",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ptz_command"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Command is being executed"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Camera cannot execute requested PTZ command"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Camera doesn't support PTZ"
          }
        },
        "tags": [
          "ptz"
        ]
      }
    },
    "/streams/{name}/camera_config": {
      "get": {
        "operationId": "camera_config_get",
        "summary": "Get one stream camera config",
        "description": "This method allows to fetch a single stream camera config info.",
        "parameters": [
          {
            "description": "Stream name.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/camera_config"
                }
              }
            },
            "description": "Whole stream config"
          }
        },
        "tags": [
          "stream"
        ]
      },
      "put": {
        "operationId": "camera_config_save",
        "summary": "Save stream camera config",
        "description": "Create or update a stream config by its name.",
        "parameters": [
          {
            "name": "name",
            "description": "stream name",
            "in": "path",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "description": "Partial stream config configuration",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/camera_config"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Created or updated stream config",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/camera_config"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Couldn't save"
          }
        },
        "tags": [
          "stream"
        ]
      }
    },
    "/streams/{name}/auth": {
      "put": {
        "operationId": "camera_auth_save",
        "summary": "Save auth for camera",
        "description": "Create or update a auth for camera by its name.",
        "parameters": [
          {
            "description": "Stream name.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/auth"
                }
              }
            },
            "description": "Whole stream config"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            },
            "description": "Couldn't save"
          }
        },
        "tags": [
          "stream"
        ]
      },
      "get": {
        "operationId": "camera_auth_get",
        "summary": "Get auth for camera",
        "description": "Create or update a auth for camera by its name.",
        "parameters": [
          {
            "description": "Stream name.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/auth"
                }
              }
            },
            "description": "Whole stream config"
          }
        },
        "tags": [
          "stream"
        ]
      }
    },
    "/streams/{name}/reboot": {
      "post": {
        "parameters": [
          {
            "description": "Stream name.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "example": "abc",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "operationId": "camera_reboot",
        "summary": "Reboot camera",
        "description": "Reboot camera",
        "responses": {
          "204": {
            "description": "Reboot in progress"
          }
        },
        "tags": [
          "stream"
        ]
      }
    },
    "/streams/{name}/firmware_update": {
      "put": {
        "operationId": "stream_firmware_update",
        "summary": "Update camera firmware",
        "description": "This method allows you to update camera firmware\n",
        "parameters": [
          {
            "name": "name",
            "description": "Stream name.",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "simple",
            "example": "abc"
          }
        ],
        "requestBody": {
          "description": "Protocol data and firmware for update camera",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/firmware_update"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Camera updated"
          }
        },
        "tags": [
          "stream"
        ]
      }
    },
    "/streams/{name}/permissions/users/{user_id}": {
      "parameters": [
        {
          "description": "Stream name",
          "in": "path",
          "name": "name",
          "required": true,
          "schema": {
            "type": "string"
          },
          "style": "simple"
        },
        {
          "description": "User identifier",
          "in": "path",
          "name": "user_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "stream_permission_user_get",
        "summary": "Get user permissions to a stream",
        "description": "Returns the permissions that a specific user has for a specified stream via stream permissions.\nShows detailed permissions a user has for this stream. This API is accessible to:\n- Users with 'can_edit' permission for the stream\n- Organization admins with 'can_edit_streams' permission\n- Domain administrators\n- Organization owners\n",
        "responses": {
          "200": {
            "description": "User's permissions to the stream",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stream_user_permission"
                }
              }
            }
          },
          "404": {
            "description": "Stream or user not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "stream"
        ]
      },
      "put": {
        "operationId": "stream_permission_user_save",
        "summary": "Update stream permissions",
        "description": "Saves permissions for a specific user to access a stream. \nThese permissions override folder-level permissions but are overridden by organization-level permissions.\nUpdates or creates direct stream permissions for a user. These permissions override folder-level permissions but are overridden by organization-level permissions. This API is accessible to:\n- Users with 'can_edit' permission for the stream\n- Organization admins with 'can_edit_streams' permission\n- Domain administrators\n- Organization owners\n",
        "requestBody": {
          "description": "Permission settings",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/stream_permissions_access"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Updated permission settings",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stream_user_permission"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "404": {
            "description": "Stream or user not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "stream"
        ]
      },
      "delete": {
        "operationId": "stream_permission_user_delete",
        "summary": "Delete stream permissions",
        "description": "Delete all permissions for a specific user to access a stream.\nRemoves direct access permissions for a user to this stream. This API is accessible to:\n- Users with 'can_edit' permission for the stream\n- Organization admins with 'can_edit_streams' permission\n- Domain administrators\n- Organization owners\n",
        "responses": {
          "204": {
            "description": "Permissions successfully deleted"
          },
          "404": {
            "description": "Stream or user not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "stream"
        ]
      }
    },
    "/streams/{name}/permissions/users": {
      "parameters": [
        {
          "description": "Stream name",
          "in": "path",
          "name": "name",
          "required": true,
          "schema": {
            "type": "string"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "stream_permissions_users_list",
        "summary": "List users with permissions to a stream",
        "description": "Returns a list of users who have direct access to the specified stream via stream permissions.\nLists all users with explicit permissions set for this stream. This API is accessible to:\n- Users with 'can_edit' permission for the stream\n- Organization admins with 'can_edit_streams' permission\n- Domain administrators\n- Organization owners\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/select"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/cursor"
          }
        ],
        "responses": {
          "200": {
            "description": "List of users with permissions to the stream",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stream_users_permissions_list"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "404": {
            "description": "Stream not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "stream"
        ]
      }
    },
    "/episodes/{episode_id}": {
      "parameters": [
        {
          "name": "episode_id",
          "description": "Episode ID",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        },
        {
          "name": "token",
          "description": "Authorization token for unauthenticated access to the episode",
          "in": "query",
          "required": false,
          "schema": {
            "type": "string"
          },
          "x-private": true
        }
      ],
      "get": {
        "operationId": "episode_get",
        "summary": "Get episode",
        "description": "This method allows you to fetch a registered episode\n",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/watcher_episode"
                }
              },
              "text/csv": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "episode"
        ]
      },
      "delete": {
        "operationId": "episode_delete",
        "summary": "Delete episode",
        "description": "This method allows you to delete a registered episode.\nOnly manually created episodes can be deleted. Episodes created automatically by the system (e.g., by video analytics) cannot be deleted.\n",
        "responses": {
          "204": {
            "description": "Episode successfully deleted"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "episode"
        ]
      }
    },
    "/episodes/{episode_id}/favorites": {
      "parameters": [
        {
          "name": "episode_id",
          "description": "Episode ID",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "post": {
        "operationId": "episode_add_to_favorites",
        "summary": "Add episode to the favorites",
        "description": "This method allows you to add an episode to the favorites.\n",
        "responses": {
          "204": {
            "description": "The episode added to the favorites."
          }
        },
        "tags": [
          "episode"
        ]
      },
      "delete": {
        "operationId": "episode_delete_from_favorites",
        "summary": "Delete episode from the favorites",
        "description": "This method allows you to delete an episode from the favorites.\n",
        "responses": {
          "204": {
            "description": "The episode deleted from the favorites."
          }
        },
        "tags": [
          "episode"
        ]
      }
    },
    "/episodes": {
      "get": {
        "parameters": [
          {
            "$ref": "#/components/parameters/select"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/cursor"
          },
          {
            "name": "episode_type",
            "description": "Episode type",
            "explode": false,
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "example": "generic"
            },
            "style": "form"
          },
          {
            "name": "media",
            "description": "Filter the collection by media name on which the episode is registered",
            "explode": false,
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "example": "cam-045"
            },
            "style": "form"
          },
          {
            "name": "updated_at_gt",
            "description": "Filter the collection by episode update time.\nThis field is rather specific because it allows to have an update stream with new/updated episodes\n",
            "explode": false,
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "utc_ms",
              "example": 1637094994000,
              "x-format-description": "Unix timestamp in milliseconds",
              "minimum": 1000000000000,
              "maximum": 10000000000000
            },
            "style": "form"
          },
          {
            "name": "poll_timeout",
            "description": "Client may ask to delay a response if there are no episodes to fetch.\nThis should be used as a long-poll mechanism for lightweight fetching episodes from origin.\n",
            "explode": false,
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "seconds",
              "example": 30,
              "x-format-description": "seconds"
            },
            "style": "form"
          },
          {
            "name": "q",
            "description": "Request for the search across the streams being processed by the inference server.\nQuery is a free-formed text that describes an object to search for and its attributes.\nQuery may include color properties (\"yellow\"), appearance attributes (\"beard\").\nResults may be inaccurate and should be reviewed by inspecting corresponding video fragments.\nIn order to use \"context search\" feature packages [flussonic-vision](https://flussonic.com/doc/watcher-vision-installation/#watcher-vision-installation) and `vision-context-search` must be installed at the \ninference server to make digital fingerprints of streams.\nIn case you use the \"q\" parameter to get a list of episodes, the following collection filters are only supported: \"media\", \"opened_at_gte\", \"opened_at_lte\".\n",
            "explode": false,
            "in": "query",
            "style": "form",
            "required": false,
            "schema": {
              "type": "string",
              "example": "yellow car"
            }
          }
        ],
        "operationId": "episodes_list",
        "summary": "List episodes",
        "description": "This method allows you to fetch registered episodes\n",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/episodes_list"
                }
              },
              "text/csv": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "episode"
        ]
      }
    },
    "/episodes/{episode_id}/token": {
      "parameters": [
        {
          "name": "episode_id",
          "description": "Episode ID",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/profile": {
      "get": {
        "operationId": "profile_get",
        "summary": "Get profile info",
        "description": "Get profile info.\n",
        "responses": {
          "200": {
            "description": "Profile info.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/profile"
                }
              }
            }
          }
        },
        "tags": [
          "profile"
        ]
      },
      "put": {
        "operationId": "profile_save",
        "summary": "Update profile info",
        "description": "Update profile info.\n",
        "requestBody": {
          "description": "Profile params.\n",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/profile"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Profile info was updated.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/profile"
                }
              }
            }
          },
          "400": {
            "description": "Couldn't save",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "profile"
        ]
      }
    },
    "/profile/device-tokens/{token}": {
      "parameters": [
        {
          "description": "Device token received from Firebase",
          "in": "path",
          "name": "token",
          "required": true,
          "schema": {
            "type": "string"
          },
          "style": "simple"
        }
      ],
      "put": {
        "description": "Save a new device token in Watcher. You can read how to create it here: https://firebase.google.com/docs/cloud-messaging/android/client?hl=en#sample-register\nYou must save and refresh token if you want to receive notifications about [camera events](#tag/profile/operation/event_subscription_create).\n",
        "summary": "Save a new device token",
        "operationId": "device_token_save",
        "requestBody": {
          "description": "Device token received from Firebase",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/device_token"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/device_token"
                }
              }
            },
            "description": "response"
          }
        },
        "tags": [
          "profile"
        ]
      },
      "delete": {
        "summary": "Delete device token",
        "description": "Delete device token. Mobile application have to delete all expired device tokens, received from Firebase.",
        "operationId": "device_token_delete",
        "responses": {
          "204": {
            "description": "response"
          }
        },
        "tags": [
          "profile"
        ]
      },
      "get": {
        "description": "Returns a device token info",
        "operationId": "device_token_get",
        "summary": "Get device token",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/device_token"
                }
              }
            },
            "description": "response"
          }
        },
        "tags": [
          "profile"
        ]
      }
    },
    "/profile/device-tokens/{token}/confirm": {
      "parameters": [
        {
          "description": "Device token received from Firebase",
          "in": "path",
          "name": "token",
          "required": true,
          "schema": {
            "type": "string"
          },
          "style": "simple"
        }
      ],
      "post": {
        "description": "Should be called by a device when notification received",
        "summary": "Confirm notification received by device",
        "operationId": "device_token_confirm",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/device_token"
                }
              }
            },
            "description": "response"
          }
        },
        "tags": [
          "profile"
        ]
      }
    },
    "/profile/subscriptions/stream_event": {
      "post": {
        "operationId": "event_subscription_create",
        "description": "Create a new event subscription",
        "summary": "Create a new event subscription on specific stream",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/subscription_request"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/subscription"
                }
              }
            }
          }
        },
        "tags": [
          "profile"
        ]
      },
      "delete": {
        "description": "Delete subscription on events",
        "operationId": "event_subscription_delete",
        "summary": "Unsubscribe from events on specific stream",
        "parameters": [
          {
            "description": "Stream identifier",
            "in": "query",
            "name": "stream_name",
            "required": true,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "204": {
            "description": "response"
          }
        },
        "tags": [
          "profile"
        ]
      }
    },
    "/profile/apikey": {
      "get": {
        "operationId": "user_apikey_get",
        "description": "Get users apikey",
        "summary": "Get users apikey",
        "responses": {
          "200": {
            "description": "Users apikey",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/apikey"
                }
              }
            }
          }
        },
        "tags": [
          "profile"
        ]
      },
      "post": {
        "operationId": "user_apikey_create",
        "description": "Create apikey for user",
        "summary": "Create new apikey for user",
        "responses": {
          "200": {
            "description": "Apikey created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/apikey"
                }
              }
            }
          }
        },
        "tags": [
          "profile"
        ]
      },
      "delete": {
        "description": "Delete apikey for user",
        "operationId": "user_apikey_delete",
        "summary": "Delete apikey for user",
        "responses": {
          "204": {
            "description": "Apikey deleted"
          }
        },
        "tags": [
          "profile"
        ]
      }
    },
    "/notifications/notify": {
      "post": {
        "operationId": "notification_send",
        "summary": "Send an arbitrary push notification",
        "description": "Send an arbitrary push notification. This method sends test push notification to user.\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/notifications_request"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Push sent\n"
          }
        },
        "tags": [
          "notifications"
        ]
      }
    },
    "/ui_settings": {
      "get": {
        "operationId": "ui_settings_get",
        "summary": "Get UI settings",
        "description": "The method allows you to fetch UI settings including branding colors, logos, etc.\nIt can work without authorization for the login page to be loaded.\n",
        "responses": {
          "200": {
            "description": "UI settings",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ui_settings_config"
                }
              }
            }
          }
        },
        "tags": [
          "config"
        ]
      }
    },
    "/web_push/subscription": {
      "parameters": [
        {
          "name": "endpoint",
          "in": "query",
          "required": true,
          "schema": {
            "type": "string"
          },
          "description": "Subscription endpoint"
        }
      ],
      "get": {
        "operationId": "web_push_subscription_existence_get",
        "summary": "Subscription existence",
        "description": "Checks for subscription on the backend\n",
        "responses": {
          "204": {
            "description": "Subscription exists"
          },
          "404": {
            "description": "Subscription does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "web_push"
        ]
      }
    },
    "/web_push/subscribe": {
      "post": {
        "operationId": "web_push_subscribe",
        "summary": "Create subscription",
        "description": "Subscribes the client to Push Messages\n",
        "requestBody": {
          "description": "Result of `PushManager: subscribe()` without `expirationTime`",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/web_push_subscription_create"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Subscription was created"
          }
        },
        "tags": [
          "web_push"
        ]
      }
    },
    "/web_push/unsubscribe": {
      "post": {
        "operationId": "web_push_unsubscribe",
        "summary": "Delete subscription",
        "description": "Deletes the subscription, so the client will no longer receive Push Messages on it\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/web_push_subscription"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Subscription was deleted"
          },
          "404": {
            "description": "Subscription was not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "web_push"
        ]
      }
    },
    "/persons": {
      "get": {
        "operationId": "persons_list",
        "summary": "List Persons",
        "description": "The list of registered videoanalytics persons\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/select"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/cursor"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/persons_list"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "persons"
        ]
      }
    },
    "/persons/{person_id}": {
      "parameters": [
        {
          "name": "person_id",
          "description": "Person's identifier",
          "in": "path",
          "required": true,
          "schema": {
            "type": "integer",
            "format": "snowflake_id",
            "x-format-description": "snowflake_id"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "person_get",
        "summary": "Get the Person",
        "description": "This method allows you to fetch the person by its identifier\n",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/person"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "persons"
        ]
      },
      "delete": {
        "operationId": "person_delete",
        "summary": "Delete person",
        "description": "Delete person by its id.",
        "parameters": [
          {
            "name": "X-Force",
            "in": "header",
            "description": "This flag allows you to delete all child objects in person, ignoring the warning signs.\nBe careful with this flag, it will delete all faces for which this person is the only one \nand the rest of the child objects\n",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "example": true,
            "default": false
          }
        ],
        "responses": {
          "204": {
            "description": "Person deleted"
          },
          "400": {
            "description": "Related objects warning",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "persons"
        ]
      }
    },
    "/vehicles": {
      "parameters": [
        {
          "$ref": "#/components/parameters/select"
        },
        {
          "$ref": "#/components/parameters/limit"
        },
        {
          "$ref": "#/components/parameters/cursor"
        }
      ]
    },
    "/vehicles/{vehicle_id}": {
      "parameters": [
        {
          "name": "vehicle_id",
          "description": "Vehicle's identifier",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string",
            "format": "license_plate",
            "x-format-description": "license_plate"
          },
          "style": "simple"
        }
      ]
    },
    "/person_lists": {
      "get": {
        "operationId": "person_lists_get",
        "summary": "Lists Person",
        "description": "This method allows you to fetch the person lists\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/select"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/cursor"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/person_lists_list"
                }
              }
            },
            "description": "Response. An array of people who have been added to this list."
          }
        },
        "tags": [
          "person_lists"
        ]
      }
    },
    "/organizations": {
      "get": {
        "operationId": "organizations_list",
        "summary": "List organizations",
        "description": "Organizations of which the user is member",
        "parameters": [
          {
            "$ref": "#/components/parameters/select"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/cursor"
          }
        ],
        "responses": {
          "200": {
            "description": "Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/organizations_list"
                }
              }
            }
          }
        },
        "tags": [
          "organization"
        ]
      },
      "post": {
        "operationId": "organization_create",
        "summary": "Create organization",
        "description": "Create new organization",
        "requestBody": {
          "description": "Organization body",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/organization"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created organization",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/organization"
                }
              }
            }
          }
        },
        "tags": [
          "organization"
        ]
      }
    },
    "/organizations/{organization_id}": {
      "parameters": [
        {
          "description": "Organization identifier",
          "in": "path",
          "name": "organization_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "organization_get",
        "summary": "Get single organization info",
        "description": "This method allows to fetch a single organization info. Refer to the `organizations_list` operation to find out what data will be returned in this method.",
        "responses": {
          "200": {
            "description": "Organization info",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/organization"
                }
              }
            }
          }
        },
        "tags": [
          "organization"
        ]
      },
      "put": {
        "operationId": "organization_save",
        "summary": "Update organization",
        "description": "Update organization by its id.",
        "requestBody": {
          "description": "Organization info",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/organization"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Updated organization",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/organization"
                }
              }
            }
          }
        },
        "tags": [
          "organization"
        ]
      },
      "delete": {
        "operationId": "organization_delete",
        "summary": "Delete organization",
        "description": "Delete organization by its id.",
        "parameters": [
          {
            "name": "X-Force",
            "in": "header",
            "description": "This flag allows you to delete all child objects in organizations, ignoring the warning signs.\nBe careful with this flag, it will delete all threads, users for which this organization is the only one and the rest of the child objects\n",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "example": true,
            "default": false
          }
        ],
        "responses": {
          "204": {
            "description": "Organization deleted"
          },
          "400": {
            "description": "Children objects warning",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "organization"
        ]
      }
    },
    "/organizations/{organization_id}/users": {
      "parameters": [
        {
          "description": "Organization identifier",
          "in": "path",
          "name": "organization_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "organization_users_list",
        "summary": "List users in organization",
        "description": "Users who are members of the organization",
        "parameters": [
          {
            "$ref": "#/components/parameters/select"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/cursor"
          }
        ],
        "responses": {
          "200": {
            "description": "Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/organization_users_list"
                }
              }
            }
          }
        },
        "tags": [
          "organization"
        ]
      }
    },
    "/organizations/{organization_id}/users/{user_id}": {
      "parameters": [
        {
          "description": "Organization identifier",
          "in": "path",
          "name": "organization_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        },
        {
          "description": "User identifier",
          "in": "path",
          "name": "user_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "organization_user_get",
        "summary": "Get single organization user info",
        "description": "This method allows to fetch a single organizations user info.",
        "responses": {
          "200": {
            "description": "Users info",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/organization_user"
                }
              }
            }
          }
        },
        "tags": [
          "organization"
        ]
      },
      "put": {
        "operationId": "organization_user_save",
        "summary": "Update organizations user",
        "description": "Update organization user by its id or adds new user to organization.",
        "requestBody": {
          "description": "Organization user info",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/organization_permissions"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Updated user info",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/organization_user"
                }
              }
            }
          }
        },
        "tags": [
          "organization"
        ]
      },
      "delete": {
        "operationId": "organization_user_delete",
        "summary": "Delete user from organization",
        "description": "Delete user from organization by its id.",
        "responses": {
          "204": {
            "description": "User deleted from organization"
          }
        },
        "tags": [
          "organization"
        ]
      }
    },
    "/organizations/{organization_id}/attendance-persons": {
      "parameters": [
        {
          "$ref": "#/components/parameters/select"
        },
        {
          "$ref": "#/components/parameters/limit"
        },
        {
          "$ref": "#/components/parameters/cursor"
        },
        {
          "name": "from",
          "description": "Timestamp metrics will be provided from. (in seconds, UTC). Default is midnight (start of) yesterday.",
          "in": "query",
          "required": false,
          "schema": {
            "example": 145678892,
            "type": "integer"
          },
          "style": "form"
        },
        {
          "name": "to",
          "description": "Timestamp metrics will be provided to. (in seconds, UTC). Default is end of the \"from\" day.",
          "in": "query",
          "required": false,
          "schema": {
            "example": 145678823,
            "type": "integer"
          },
          "style": "form"
        },
        {
          "description": "Organization identifier",
          "in": "path",
          "name": "organization_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        }
      ]
    },
    "/organizations/{organization_id}/attendance-vehicles": {
      "parameters": [
        {
          "$ref": "#/components/parameters/select"
        },
        {
          "$ref": "#/components/parameters/limit"
        },
        {
          "$ref": "#/components/parameters/cursor"
        },
        {
          "name": "from",
          "description": "Timestamp metrics will be provided from. (in seconds, UTC). Default is midnight (start of) yesterday.",
          "in": "query",
          "required": false,
          "schema": {
            "example": 145678892,
            "type": "integer"
          },
          "style": "form"
        },
        {
          "name": "to",
          "description": "Timestamp metrics will be provided to. (in seconds, UTC). Default is end of the \"from\" day.",
          "in": "query",
          "required": false,
          "schema": {
            "example": 145678823,
            "type": "integer"
          },
          "style": "form"
        },
        {
          "description": "Organization identifier",
          "in": "path",
          "name": "organization_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        }
      ]
    },
    "/organizations/{organization_id}/folders": {
      "parameters": [
        {
          "description": "Organization identifier",
          "in": "path",
          "name": "organization_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "folder_list",
        "summary": "Get list of folders",
        "description": "This method allows to fetch a list of folders info.",
        "responses": {
          "200": {
            "description": "List of folders info",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/folders_list"
                }
              }
            }
          }
        },
        "tags": [
          "folder"
        ]
      },
      "post": {
        "operationId": "folder_create",
        "summary": "Create folder",
        "description": "Create folder.",
        "requestBody": {
          "description": "Folder info",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/folder"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Created folder",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/folder"
                }
              }
            }
          }
        },
        "tags": [
          "folder"
        ]
      }
    },
    "/organizations/{organization_id}/folders/{folder_id}": {
      "parameters": [
        {
          "description": "Organization identifier",
          "in": "path",
          "name": "organization_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        },
        {
          "description": "Folder identifier",
          "in": "path",
          "name": "folder_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "folder_get",
        "summary": "Get folder info",
        "description": "This method allows to fetch folder info.",
        "responses": {
          "200": {
            "description": "Folder info",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/folder"
                }
              }
            }
          }
        },
        "tags": [
          "folder"
        ]
      },
      "put": {
        "operationId": "folder_save",
        "summary": "Save folder",
        "description": "Save folder.",
        "requestBody": {
          "description": "Folder info",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/folder"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Created folder",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/folder"
                }
              }
            }
          }
        },
        "tags": [
          "folder"
        ]
      },
      "delete": {
        "operationId": "folder_delete",
        "summary": "Delete folder",
        "description": "This method allows to delete a folder.",
        "responses": {
          "204": {
            "description": "Folder deleted"
          }
        },
        "tags": [
          "folder"
        ]
      }
    },
    "/organizations/{organization_id}/folders/{folder_id}/users": {
      "parameters": [
        {
          "description": "Organization identifier",
          "in": "path",
          "name": "organization_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        },
        {
          "description": "Folder identifier",
          "in": "path",
          "name": "folder_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "folder_users_list",
        "summary": "Get a list of users in a folder",
        "description": "This method allows to fetch a list of users in a folder.",
        "responses": {
          "200": {
            "description": "List of users in a folder",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/folder_users_list"
                }
              }
            }
          }
        },
        "tags": [
          "folder"
        ]
      }
    },
    "/organizations/{organization_id}/folders/{folder_id}/users/{user_id}": {
      "parameters": [
        {
          "description": "Organization identifier",
          "in": "path",
          "name": "organization_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        },
        {
          "description": "Folder identifier",
          "in": "path",
          "name": "folder_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        },
        {
          "description": "User identifier",
          "in": "path",
          "name": "user_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "folder_user_get",
        "summary": "Get user in a folder",
        "description": "This method allows to fetch user in a folder.",
        "responses": {
          "200": {
            "description": "Folder user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/folder_user"
                }
              }
            }
          }
        },
        "tags": [
          "folder"
        ]
      },
      "put": {
        "operationId": "folder_user_save",
        "summary": "Save user in a folder",
        "description": "Save user info in a folder.",
        "requestBody": {
          "description": "Folder user",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/folder_user"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Saved user in a folder",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/folder_user"
                }
              }
            }
          }
        },
        "tags": [
          "folder"
        ]
      },
      "delete": {
        "operationId": "folder_user_delete",
        "summary": "Delete user in a folder",
        "description": "This method allows to delete user info in a folder.",
        "responses": {
          "204": {
            "description": "Deleted user in a folder"
          }
        },
        "tags": [
          "folder"
        ]
      }
    },
    "/organizations/{organization_id}/presets": {
      "parameters": [
        {
          "description": "Organization identifier",
          "in": "path",
          "name": "organization_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        }
      ],
      "put": {
        "operationId": "organization_preset_save",
        "summary": "Update organizations preset",
        "description": "Save organization preset by its id or adds new preset to organization.",
        "requestBody": {
          "description": "Organization preset info",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/organization_preset"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Update organization preset info",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/preset"
                }
              }
            }
          },
          "400": {
            "description": "Couldn't update organization preset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "organization"
        ]
      }
    },
    "/organizations/{organization_id}/presets/{preset_id}": {
      "delete": {
        "summary": "Delete preset from organization",
        "description": "This method allows to remove a specific preset from organization.",
        "operationId": "delete_organization_preset",
        "parameters": [
          {
            "name": "organization_id",
            "in": "path",
            "required": true,
            "description": "Organization identifier",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "preset_id",
            "in": "path",
            "required": true,
            "description": "Preset identifier",
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "Couldn't get organization preset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "organization"
        ]
      }
    },
    "/organizations/{organization_id}/invite": {
      "parameters": [
        {
          "description": "Organization identifier",
          "in": "path",
          "name": "organization_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        }
      ],
      "post": {
        "operationId": "organization_invite_create",
        "summary": "Create organization invite key",
        "description": "This method allows to create a single organizations invite key. \nUsing this key user can invite other users to the organization. \nOnly organization owner can create invite key.\n",
        "requestBody": {
          "description": "Setup for the user invitation",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/organization_invite_setup"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Invite key created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/organization_invite_key"
                }
              }
            }
          }
        },
        "tags": [
          "organization"
        ]
      }
    },
    "/organizations/invite/{invite_key}": {
      "parameters": [
        {
          "description": "Invite key",
          "in": "path",
          "name": "invite_key",
          "required": true,
          "schema": {
            "type": "string"
          },
          "style": "simple"
        }
      ],
      "put": {
        "operationId": "organization_invite_accept",
        "summary": "Accept organization invite",
        "description": "This method allows to accept organization invite and add user to organization.",
        "responses": {
          "204": {
            "description": "User added to organization"
          }
        },
        "tags": [
          "organization"
        ]
      },
      "get": {
        "operationId": "get_invite_short_info",
        "summary": "Get organization invite short info",
        "description": "This method allows to get short info about organization invite.",
        "responses": {
          "200": {
            "description": "Invite short info",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/organization_base"
                }
              }
            }
          }
        },
        "tags": [
          "organization"
        ]
      }
    },
    "/users": {
      "get": {
        "operationId": "users_list",
        "summary": "List of users",
        "description": "List of available users\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/select"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/cursor"
          },
          {
            "name": "organization_id",
            "description": "Organization identifier to select users only available for this organization.\nIf the `organization_id` is not transferred, all available users will be returned.\n",
            "explode": false,
            "in": "query",
            "style": "form",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/users"
                }
              }
            }
          }
        },
        "tags": [
          "user"
        ]
      },
      "post": {
        "operationId": "user_create",
        "summary": "Create user",
        "description": "This method allows you to create a user\n",
        "parameters": [
          {
            "name": "Idempotency-Key",
            "description": "The idempotency token guarantees that the same operation will not be executed twice.\nIt is especially important in a cloud platform to make sure that credits are not deducted from the account several times for the same action.\n",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "example": "8e03978e-40d5-43e8-bc93-6894a57f9324",
              "x-format-description": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "User data",
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/user_create"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/user"
                }
              }
            }
          }
        },
        "tags": [
          "user"
        ]
      }
    },
    "/users/{user_id}": {
      "parameters": [
        {
          "name": "user_id",
          "description": "User's identifier",
          "in": "path",
          "required": true,
          "schema": {
            "type": "integer",
            "format": "snowflake_id",
            "x-format-description": "snowflake_id"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "user_get",
        "summary": "Get a user",
        "description": "This method allows you to fetch the user by its identifier\n",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/user"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "user"
        ]
      },
      "put": {
        "operationId": "user_save",
        "summary": "Save user",
        "description": "This method allows you to update user data\n",
        "requestBody": {
          "description": "User data",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/user"
                }
              }
            }
          }
        },
        "tags": [
          "user"
        ]
      },
      "delete": {
        "operationId": "user_delete",
        "summary": "Delete a user",
        "description": "This method allows you to delete a user\n",
        "responses": {
          "204": {
            "description": "Successful deleted"
          }
        },
        "tags": [
          "user"
        ]
      }
    },
    "/users/{user_id}/apikey": {
      "parameters": [
        {
          "name": "user_id",
          "in": "path",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "description": "User identifier",
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "users_apikey_get",
        "description": "The API key is used for authentication in API requests, allowing access to protected resources without using a password.\n",
        "summary": "Get user's API key",
        "responses": {
          "200": {
            "description": "User's API key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/apikey"
                }
              }
            }
          }
        },
        "tags": [
          "user"
        ]
      },
      "post": {
        "operationId": "users_apikey_create",
        "description": "The API key is used for authentication in API requests, allowing access to protected resources without using a password.\n",
        "summary": "Create new API key for user",
        "responses": {
          "200": {
            "description": "API key created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/apikey"
                }
              }
            }
          }
        },
        "tags": [
          "user"
        ]
      }
    },
    "/users/{user_id}/organization/{organization_id}/folders": {
      "parameters": [
        {
          "name": "user_id",
          "in": "path",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "description": "User identifier",
          "style": "simple"
        },
        {
          "name": "organization_id",
          "in": "path",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "description": "Organization identifier",
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "user_organization_folders_list",
        "summary": "Get user's folders in organization",
        "description": "Get list of folders available for user in specific organization",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/user_folders"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "user"
        ]
      }
    },
    "/users/{user_id}/organization": {
      "parameters": [
        {
          "name": "user_id",
          "in": "path",
          "required": true,
          "description": "User identifier",
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        },
        {
          "name": "can_edit",
          "in": "query",
          "description": "A parameter to filter organizations based on their edit availability for the current user",
          "required": false,
          "schema": {
            "type": "boolean"
          }
        }
      ],
      "get": {
        "operationId": "user_organizations_list",
        "summary": "Get user's organizations",
        "description": "Get list of organizations available for user\n",
        "responses": {
          "200": {
            "description": "Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/organizations_list"
                }
              }
            }
          }
        },
        "tags": [
          "user"
        ]
      }
    },
    "/users/{user_id}/permissions/streams/{name}": {
      "parameters": [
        {
          "description": "User identifier",
          "in": "path",
          "name": "user_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        },
        {
          "description": "Stream name",
          "in": "path",
          "name": "name",
          "required": true,
          "schema": {
            "type": "string"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "user_stream_permission_get",
        "summary": "Get user permissions to a stream",
        "description": "Returns the permissions that the user has for a specified stream via stream permissions.\nAllows viewing user-specific stream permissions. This API is accessible to:\n- The user themselves\n- Organization admins with 'can_edit_users' permission\n- Domain administrators\n- Organization owners\n",
        "responses": {
          "200": {
            "description": "User's permissions to the stream",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/user_stream_permission"
                }
              }
            }
          },
          "404": {
            "description": "Stream or user not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "user"
        ]
      },
      "put": {
        "operationId": "user_stream_permission_save",
        "summary": "Update user's stream permissions",
        "description": "Save permissions for the user to access a stream.\nThese permissions override folder-level permissions but are overridden by organization-level permissions.\nUpdates or creates permissions for a user to access a specific stream. This API is accessible to:\n- Organization admins with 'can_edit_users' permission\n- Domain administrators\n- Organization owners\n",
        "requestBody": {
          "description": "Permission settings",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/stream_permissions_access"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Updated permission settings",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/user_stream_permission"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "404": {
            "description": "Stream or user not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "user"
        ]
      },
      "delete": {
        "operationId": "user_stream_permission_delete",
        "summary": "Delete stream permissions",
        "description": "Delete all permissions for the user to access a stream.\nRemoves direct permissions for a user to access a specific stream. Note that the user may still have access via organization or folder permissions. This API is accessible to:\n- Organization admins with 'can_edit_users' permission\n- Domain administrators\n- Organization owners\n",
        "responses": {
          "204": {
            "description": "Permissions successfully deleted"
          },
          "404": {
            "description": "Stream or user not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "user"
        ]
      }
    },
    "/users/{user_id}/permissions/streams": {
      "parameters": [
        {
          "description": "User identifier",
          "in": "path",
          "name": "user_id",
          "required": true,
          "schema": {
            "type": "integer"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "user_streams_permissions_list",
        "summary": "List streams accessible to a user",
        "description": "Returns a list of streams to which the specified user has direct access via stream permissions.\nLists all streams where a user has explicit permissions set. This API is accessible to:\n- The user themselves\n- Organization admins with 'can_edit_users' permission\n- Domain administrators\n- Organization owners\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/select"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/cursor"
          }
        ],
        "responses": {
          "200": {
            "description": "List of streams accessible to the user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/user_streams_permissions_list"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "404": {
            "description": "User not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "user"
        ]
      }
    },
    "/agent_activation_token": {
      "post": {
        "operationId": "agent_activation_token_create",
        "summary": "Create activation token",
        "description": "This method creates activation token for agent.\nThis token used by mobile app in qr-code for wifi camera with agent for adding camera with agent in watcher.\n",
        "requestBody": {
          "description": "The fields with which the camera will be created\n",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/agent_activation_token_request"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/agent_activation_token"
                }
              }
            }
          }
        },
        "tags": [
          "agent"
        ]
      }
    },
    "/agent_activation_token/{token}": {
      "parameters": [
        {
          "name": "token",
          "description": "Token for agent activation\n",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "agent_activation_token_get",
        "summary": "Check activation token provisioned to watcher",
        "description": "This method allows you to check that camera with agent was provisioned to watcher.\nIf you got 404 on this method you - token not existing and you must create a new one to add camera with agent.\nIf no camera_name field in response - camera not provisioned yet to watcher.\nIf camera_name field in response - camera provisioned to watcher.\n",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/agent_activation_token"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "agent"
        ]
      }
    },
    "/presets": {
      "get": {
        "operationId": "presets_list",
        "summary": "List presets",
        "description": "The presets in Watcher is a set of DVR and analytics parameters that you can use as a template when creating and configuring cameras.\nWhen you select a preset in the camera settings, the parameters from the preset are populated to the camera settings.\nA set of presets on the camera is defined by the set of presets selected for the camera's Organization.\nhttps://flussonic.com/doc/manage-presets-in-watcher-ui/\n\nThis method is used to get info about presets.\nIf the `organization_id` is transferred this method will return presets only allowed in organization with that Id.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/select"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/cursor"
          },
          {
            "name": "organization_id",
            "description": "Organization identifier to select presets only available for this organization.\nIf the `organization_id` is not transferred, all available presets will be returned.\n",
            "in": "query",
            "schema": {
              "type": "integer"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/presets_list"
                }
              }
            }
          }
        },
        "tags": [
          "preset"
        ]
      }
    },
    "/presets/{id}": {
      "parameters": [
        {
          "name": "id",
          "description": "Preset's identifier",
          "in": "path",
          "required": true,
          "schema": {
            "type": "integer",
            "format": "snowflake_id",
            "x-format-description": "snowflake_id"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "preset_get",
        "summary": "Get one preset",
        "description": "This method is used to get info about preset by its id.\n",
        "responses": {
          "200": {
            "description": "Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/preset"
                }
              }
            }
          }
        },
        "tags": [
          "preset"
        ]
      }
    },
    "/mosaics": {
      "get": {
        "operationId": "mosaics_list",
        "summary": "List mosaics",
        "parameters": [
          {
            "$ref": "#/components/parameters/select"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/cursor"
          }
        ],
        "description": "Returns the list of all mosaics.\nMosaics allow you to combine multiple cameras to display on a single screen.\n",
        "responses": {
          "200": {
            "description": "Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/mosaics_list"
                }
              }
            }
          }
        },
        "tags": [
          "mosaics"
        ]
      },
      "post": {
        "operationId": "mosaic_create",
        "summary": "Create mosaic",
        "description": "This method allows you to create a mosaic\n",
        "parameters": [
          {
            "name": "Idempotency-Key",
            "description": "The idempotency token guarantees that the same operation will not be executed twice.\nIt is especially important in a cloud platform to make sure that credits are not deducted from the account several times for the same action.\n",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "example": "8e03978e-40d5-43e8-bc93-6894a57f9324",
              "x-format-description": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Mosaic data",
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/mosaic_save"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/mosaic"
                }
              }
            }
          }
        },
        "tags": [
          "mosaics"
        ]
      }
    },
    "/mosaics/{mosaic_id}": {
      "parameters": [
        {
          "description": "Mosaic identifier",
          "in": "path",
          "name": "mosaic_id",
          "required": true,
          "schema": {
            "example": 15,
            "type": "integer"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "mosaic_get",
        "summary": "Get mosaic detail",
        "description": "This method is used to get info about mosaic by its id.",
        "responses": {
          "200": {
            "description": "Mosaic info",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/mosaic"
                }
              }
            }
          }
        },
        "tags": [
          "mosaics"
        ]
      },
      "delete": {
        "operationId": "mosaic_delete",
        "summary": "Delete a mosaic",
        "description": "This method allows you to delete a mosaic\n",
        "responses": {
          "204": {
            "description": "Successfully deleted"
          }
        },
        "tags": [
          "mosaics"
        ]
      },
      "put": {
        "operationId": "mosaic_save",
        "summary": "Save mosaic",
        "description": "This method allows you to update mosaic data\n",
        "requestBody": {
          "description": "Mosaic data",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/mosaic_save"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/mosaic"
                }
              }
            }
          }
        },
        "tags": [
          "mosaics"
        ]
      }
    },
    "/messages": {
      "get": {
        "operationId": "messages_list",
        "summary": "List of messages",
        "description": "List of messages\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/cursor"
          }
        ],
        "responses": {
          "200": {
            "description": "Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/messages"
                }
              }
            }
          },
          "401": {
            "description": "Not authenticated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "403": {
            "description": "Permission denied",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "messages"
        ]
      },
      "post": {
        "operationId": "message_send",
        "summary": "Send a message",
        "description": "This method allows you to send a message to a user\n",
        "requestBody": {
          "description": "Message data",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/message_send"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/message_response"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "messages"
        ]
      }
    },
    "/messages/{message_id}": {
      "parameters": [
        {
          "name": "message_id",
          "description": "Message identifier",
          "in": "path",
          "required": true,
          "schema": {
            "type": "integer",
            "format": "snowflake_id",
            "x-format-description": "snowflake_id"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "message_get",
        "summary": "Get a message",
        "description": "This method allows you to fetch the message by its identifier\n",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/message"
                }
              }
            },
            "description": "Response"
          },
          "500": {
            "description": "Internal server error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "messages"
        ]
      },
      "delete": {
        "operationId": "message_delete",
        "summary": "Delete a message",
        "description": "This method allows you to delete a message\n",
        "responses": {
          "204": {
            "description": "Successful deleted"
          },
          "401": {
            "description": "Not authenticated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "403": {
            "description": "Permission denied",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "messages"
        ]
      },
      "put": {
        "operationId": "message_update",
        "summary": "Update message",
        "description": "Update message by its id.",
        "requestBody": {
          "description": "Message info",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/message_change_request"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Updated message",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/message"
                }
              }
            }
          }
        },
        "tags": [
          "messages"
        ]
      }
    }
  },
  "security": [
    {
      "basicAuth": []
    },
    {
      "bearerAuth": []
    }
  ],
  "servers": [
    {
      "description": "your local installation",
      "url": "http://localhost:80/watcher/client-api/v3"
    }
  ],
  "tags": [
    {
      "name": "agent"
    },
    {
      "name": "stream"
    },
    {
      "name": "auth"
    },
    {
      "name": "episode"
    },
    {
      "name": "profile"
    },
    {
      "name": "config"
    },
    {
      "name": "web_push"
    },
    {
      "name": "persons"
    },
    {
      "name": "person_lists"
    },
    {
      "name": "organization"
    },
    {
      "name": "preset"
    },
    {
      "name": "notifications"
    },
    {
      "name": "mosaics"
    },
    {
      "name": "ptz"
    },
    {
      "name": "user"
    },
    {
      "name": "folder"
    },
    {
      "name": "messages"
    }
  ]
}